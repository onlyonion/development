# 集群容错

## 简易流程

	Cilent		==> 	Provider
	接口 + 入参 > 序列化 > 发送字节流	---> 接收字节流 > 序列化 > 接口 + 入参

	Provider	==> 	Cilent
	结果 > 序列化 > 发送字节流		---> 接收字节流 > 序列化 > 接口 + 出参

1.	序列化组件，因为需要远程调用，所以需要将参数以二进制流的形式进行编码操作
2.	发送组件，将二进制流发送到服务端
3.	接收组件，接收调用端发送的二进制流以及接收服务端返回的二进制流

将调用端以消费者的身份进行信息注册
监听注册中心的信息变化以刷新本地对服务注册信息的缓存

## 负载均衡 Load Balance

1.	ConsistentHashLoadBalance	一致性Hash策略，具体配置方法可以参考Dubbo文档。相同调用参数的请求会发送到同一个服务提供方节点上，如果某个节点发生故障无法提供服务，则会基于一致性Hash算法映射到虚拟节点上（其他服务提供方）
2.	LeastActiveLoadBalance		根据请求调用的次数计数，处理请求更慢的节点会受到更少的请求
3.	RandomLoadBalance			随机策略，可以设置权重，有利于充分利用服务器的资源，高配的可以设置权重大一些，低配的可以稍微小一些
4.	RoundRobinLoadBalance		轮询策略


## 集群容错模式

1.	FailoverCluster		失败转移，当出现失败，重试其它服务器，通常用于读操作，但重试会带来更长延迟。 default
2.	FailfastCluster 	快速失败，只发起一次调用，失败立即报错，通常用于非幂等性的写操作。
3.	FailsafeCluster		失败安全，出现异常时，直接忽略，通常用于写入审计日志等操作。 
4.	FailbackCluster 	失败自动恢复，后台记录失败请求，定时重发，通常用于消息通知操作。
5.	ForkingCluster		并行调用，只要一个成功即返回，通常用于实时性要求较高的操作，但需要浪费更多服务资源。
6.	BroadcastCluster	广播调用所有提供者，逐个调用，任意一台报错则报错（2.1.0开始支持）。通常用于通知所有提供者更新缓存或日志等本地资源信息。


### 失效转移 FailoverCluster 
当消费端发起一次调用，如果集群容错模式选择的是FailoverCluster模式(缺省模式)，当调用发生失败会自动发起切换，重试其它服务器。


通过循环重复调用方法，如果调用得到响应，则正常返回，产生的异常作为结果的成员。如果得不到响应如超时，网络异常，序列化失败等问题则去尝试重试

通过超时判定实现我们发现，当一个任务处理时间很久，而消费端配置的超时时间又很短就会出现消费端产生超时异常，而服务提供方却成功完成了操作的现象。
因此对服务提供方的处理时间做出规划，配置合理的超时时间，或通过回调方法返回结果给消费端。这样避免消费端发生超时异常，而服务提供方处理完成的问题。

### 快速失败 Failfast Cluster
调用只执行一次，失败则立即报错。这种模式适用于非幂等性操作，每次调用的副作用是不同的，如写操作，比如交易系统我们要下订单，如果一次失败就应该让它失败，通常由服务消费方控制是否重新发起下订单操作请求（另一个新的订单）



## 注册中心
如果不使用注册中心，服务消费方也能够直接调用服务提供方发布的服务，这样需要服务提供方将服务地址暴露给服务消费方，而且也无法使用监控中心的功能，这种方式成为直连。
如果我们使用注册中心，服务提供方将服务发布到注册中心，而服务消费方可以通过注册中心订阅服务，接收服务提供方服务变更通知，这种方式可以隐藏服务提供方的细节，包括服务器地址等敏感信息，而服务消费方只能通过注册中心来获取到已注册的提供方服务，而不能直接跨过注册中心与服务提供方直接连接。这种方式的好处是还可以使用监控中心服务，能够对服务的调用情况进行监控分析，还能使用Dubbo服务管理中心，方便管理服务，我们在这里使用的是这种方式，也推荐使用这种方式

Multicast注册中心
Zookeeper注册中心
Redis注册中心
Simple注册中心


# question

## 1. Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？ 

可以，启动dubbo时，消费者会从zk拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用
注册中心对等集群，任意一台宕掉后，会自动切换到另一台 
注册中心全部宕掉，服务提供者和消费者仍可以通过本地缓存通讯 
服务提供者无状态，任一台 宕机后，不影响使用 
服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复 

## 2. dubbo连接注册中心和直连的区别 

在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连， 
点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，

服务注册中心，动态的注册和发现服务，使服务的位置透明，并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover， 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 
服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，
注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外，注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者 
注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表 
注册中心和监控中心都是可选的，服务消费者可以直连服务提供者

## 3. Dubbo在安全机制方面是如何解决的 

Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。

### 1. 通讯协议
1.  dubbo://    Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况
2.  rmi://      RMI 协议采用 JDK 标准的 java.rmi.* 实现，采用阻塞式短连接和 JDK 标准序列化方式
3.  hessian
4.  http://
5.  WebService
6.  thrift
7.  memcached://
8.  redis://

### 2. 注册中心
1.  Multicast 注册中心
2.  zookeeper 注册中心
3.  redis 注册中心
4.  Simple 注册中心

### 3. 集群容错

