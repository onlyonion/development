
分布式事务解决方案

* [二阶段提交](https://github.com/yu199195/Raincat)
* [tcc分布式事务解决方案](https://github.com/yu199195/hmily)
* [基于消息队列最终一致性](https://github.com/yu199195/myth)
* [源码分析系列博客地址](https://yu199195.github.io/)



### 理论基础
JDBC、JTA
ACID
CAP
BASE

### 产生原因
* services  多服务节点（服务拆分，每个服务一个库）
* resources 多数据库节点（同一服务分库），跨数据源

### 解决

解决思想
将业务中的事务分解成一个个在独立分库上执行的子事务。
用异步重试的方式执行这些子事务，由框架或应用保证重试的 “幂等”。
如果需要回滚，以同样方式执行另一组子事务组成的补偿操作，恢复事务前的业务状态。

#### DB层解决（刚性事务，严格ACID） 
合并微服务；基于XA的2PC

#### 分布式事务组件 + 业务层配合（柔性事务）
##### TCC（应用层的 2PC ）
两阶段提交的一个变种，解决了XA的一些缺点
1. 解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群
2. 同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小
3. 数据一致性，有了补偿机制之后，由业务活动管理器控制一致性

Try-Confirm-Cancel:
Try阶段：尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）
Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。
Cancel阶段：取消执行，释放Try阶段预留的业务资源 Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。

##### 本地事务表（本地消息表）
ebay
将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。 

blog-job-retry
1. 写本地消息日志，数据库ACID保证一致性
2. 定时任务轮询（扫表），发送消息（服务接口调用），更新状态
3. 异常重试，保证幂等

##### MQ事务
在RocketMQ中实现了分布式事务，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部

1. send start mq
2. execute local tx
3. send comfirm mq
4. mqserver do send to recevier until success

##### Saga事务
将长事务拆分为多个**本地短事务**，由Saga**事务协调器**协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用**补偿**操作

#### 业务层要求
可查询
超时重试
幂等
可补偿

[再有人问你分布式事务，把这篇扔给他](https://www.cnblogs.com/bigben0123/p/9453830.html)
[深入理解分布式事务](http://www.codeceo.com/article/distributed-transaction.html)
