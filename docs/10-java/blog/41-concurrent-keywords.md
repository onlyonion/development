## Java多线程关键字

* volatitle
* final
* synchronized

> 缓存不一致的问题
>> 在增加了增加了L1、L2 Cache之后，CPU何时将变量从独享缓存刷新会共享内存，独享缓存是否从共享内存加载变量，时间上都是不可确定的，这就造成了缓存不一致的问题。

### 1. volatitle

特性：
1. 保证共享变量对所有线程可见，但不保证原子性
volatile语义是同步，通过共享变量的方式，完成线程间的通信
volatile保证指令赋值完后的变量立即同步回主内存中，声明并通知其他线程当前赋值的变量已经失效，其他线程在下次使用时会放弃工作内存中变量，使用主内存中的变量。这样就完成了线程间对于volatile修饰的变量的通信。

2. 轻量级的synchronized
不会引起线程上下文的切换和调度

3. 禁止指令重排序优化

实现原理：
lock前缀的指令在多核处理器下会引发了两件事情。
1. 将当前处理器缓存行的数据会写回到系统内存。
2. 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效

> 原子性
原子操作是一个或多个不可中断的操作，要么一次性完全执行完毕，要么就不执行，最终状态不存在有些操作执行完，有些操作没有执行，在外部看来是不可分割的整体（比如化学中的原子，当然原子也是可以再分割的，不过站在分子层面，原子是最小的不可分割的），原子操作关注的是不被线程调度器中断的操作。

volatile关注可见性，而与原子性没有关系。volatile关注点在于从工作内存刷新回主内存，而原子操作关注的是否不被打断。原子和同步目的都是让不同线程可以安全地访问共享变量的两种处理方式，避免造成内存一致性错误。

> 可见性
当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值

### 2. final

- 修饰变量        只读
- 修饰方法        不能被重写
- 修饰类        不能被继承

优点
1. final关键字提高了性能。JVM和Java应用都会缓存final变量。
2. final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
3. 当构造函数退出时，final域的值是被保证对其他线程可见的。
4. 使用final关键字，JVM会对方法、变量及类进行优化。

final和abstract这两个关键字是反相关的，final类就不可能是abstract的
final方法在编译阶段绑定，称为静态绑定(static binding)

final的局限性
* final域在声明的时候，这个域必须在构造函数退出之前被初始化完成。有两种方式可以初始化final域：
* 强调的一点是，当声明一个final的引用时， 只能说明该引用是不可变的，但是数据是可变的。

什么时候需要使用final
一种说法是：任何不希望域被改变的时候都可以使用final。
另外一种是：如果一个对象可以被多个线程访问到，但是并没有被声明为final，那么你需要提供额外的线程安全机制。其他的方式包括声明为volatile 、使用synchronized、显示锁等。

#### 多线程语义

编译器和处理器要遵守两个重排序规则：
在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。

写重排序
JMM禁止编译器把final域的写重排序到构造函数之外。
编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。

读重排序
在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。

### 3. synchronized

1. 修饰普通方法
2. 修饰静态方法
3. 修饰代码块


## Java Object多线程方法 wait(), notify(), notifyAll()


### 等待/通知模式的经典范式

http://www.cnblogs.com/wxd0108/p/5479442.html

#### 等待方:

1. 获取对象的锁 
2. 如果条件不满足 那么调用对象的wait方法 被通知后仍要检查条件、 
3. 条件满足则执行对应的逻辑

伪码:

```java
synchronized(对象){
    while(条件不满足){
        对象.wait()
    }
    对应的处理逻辑
}
```

#### 通知方:

1. 获得对象的锁 
2. 改变条件 
3. 通知所有等待在对象上的线程

伪码:

```java
synchronized(对象){
    改变条件
    对象.notifyAll();
}
```
