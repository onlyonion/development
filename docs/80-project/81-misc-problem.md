## [C10K问题](https://www.jianshu.com/p/ba7fa25d3590)
最早是由Dan Kegel进行归纳和总结的，并且他也系统的分析和提出解决方案

新到来一个TCP连接，就需要分配一个进程。
当创建的进程或线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞，进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质。

#### C10K问题的解决方案
从网络编程技术的角度来说，主要思路：
* 每个连接分配一个独立的线程/进程
* 同一个线程/进程同时处理多个连接
  * select 文件句柄数量 逐个检查吞吐量低
  * poll
  * epoll C10K问题的killer，他不去轮询监听所有文件句柄是否已经就绪。epoll只对发生变化的文件句柄感兴趣。
  * 异步I/O以及Windows

#### epoll
其工作机制是，使用"事件"的就绪通知方式，通过epoll_ctl注册文件描述符fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd, epoll_wait便可以收到通知, 并通知应用程序。
而且epoll使用一个文件描述符管理多个描述符,将用户进程的**文件描述符**的事件存放到内核的一个**事件表**中, 这样数据只需要从内核缓存空间拷贝一次到用户进程地址空间。而且epoll是通过**内核与用户空间共享内存**方式来实现事件就绪消息传递的，其效率非常高。但是epoll是依赖系统的(Linux)。
