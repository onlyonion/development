## [C10K问题](https://www.jianshu.com/p/ba7fa25d3590)
最早是由Dan Kegel进行归纳和总结的，并且他也系统的分析和提出解决方案

新到来一个TCP连接，就需要分配一个进程。
当创建的进程或线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞，进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质。

#### C10K问题的解决方案
从网络编程技术的角度来说，主要思路：
* 每个连接分配一个独立的线程/进程
* 同一个线程/进程同时处理多个连接
  * select 文件句柄数量 逐个检查吞吐量低
  * poll
  * epoll C10K问题的killer，他不去轮询监听所有文件句柄是否已经就绪。epoll只对发生变化的文件句柄感兴趣。
  * 异步I/O以及Windows

#### epoll
其工作机制是，使用"事件"的就绪通知方式，通过epoll_ctl注册文件描述符fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd, epoll_wait便可以收到通知, 并通知应用程序。
而且epoll使用一个文件描述符管理多个描述符,将用户进程的**文件描述符**的事件存放到内核的一个**事件表**中, 这样数据只需要从内核缓存空间拷贝一次到用户进程地址空间。而且epoll是通过**内核与用户空间共享内存**方式来实现事件就绪消息传递的，其效率非常高。但是epoll是依赖系统的(Linux)。


### HashMap长度为2的幂次方
https://blog.csdn.net/qq_44790505/article/details/121866549
HashMap长度为2的幂次方的原因是为了减少Hash碰撞，尽量使Hash算法的结果均匀。
其中有个( n - 1) & hash的方法，那么这个方法是干什么的呢？

HashMap为了存取高效，就要尽量减少碰撞，将数据分配均匀，那么如何分配均匀，此时主要靠将数据存入到那个链表中的算法，这个算法就是( n - 1) & hash。& 是按位与运算，是一个位运算，而在计算机中位运算的效率很高，这就是不用%运算的原因。

按位与&的计算方式为当对应位置的数据都为1时，运算结果也为1。因此当HashMap的容量是2的幂次方时，( n - 1)的2进制都是111..11的形式，在与添加元素的hash值进行位运算时能够充分的散列，使添加的元素能均匀的分布在HashMap的每个位置上，减少hash碰撞。
