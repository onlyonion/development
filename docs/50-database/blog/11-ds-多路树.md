
## B树
B树（B-tree）是一种树状数据结构，能够用来存储**排序后的数据**。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。
B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。
B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。

> 根节点 -> 关键字K1,...,Kn -> 找到成功，找不到查找Ki, Ki+1之间

在B树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），
若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，
此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。

### 多路搜索树
B树作为一种多路搜索树（并不是二叉的）：
1. 定义任意非叶子结点最多只有M个儿子；且M>2；
2. 根结点的儿子数为[2, M]；
3. 除根结点以外的非叶子结点的儿子数为[M/2, M]；
4. 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
5. 非叶子结点的关键字个数=指向儿子的指针个数-1；
6. 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
7. 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
8. 所有叶子结点位于同一层；

## B+树
B+的性质：
1. 所有关键字都出现在**叶子结点的链表中**（稠密索引），且链表中的关键字恰好是**有序的**；
2. 不可能在非叶子结点命中；
3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
4. 更适合文件索引系统。


## B树与B+树

| 性质                 | B                        | B+                                                         |
| :------------------- | :----------------------- | :--------------------------------------------------------- |
| 叉度路阶             | 每个结点至多有m棵子树    | 每个分支结点最多m棵子树                                    |
| 子树个数             | 至少两棵子树             | 非叶根结点至少两棵子树，其他分支结点至少m/2棵子树          |
| 子树个数与关键字个数 | m/2棵子树                | 结点子树个数与关键字个数相同                               |
| 分支结点             | 关键字个数、关键字、指针 | 分支结点仅包含子节点最大关键字，指针                       |
| 叶结点               | 同一层次                 | 所有叶结点全部关键字，叶结点内关键字排序，叶结点间排序链接 |
| 查找步骤             | 查找结点、结点内查找     | 叶结点间顺序查找、根结点多路查找                           |
| 查找路径             | 分支结点可能终止         | 根结点到叶结点路径                                         |


## 平衡多路查找树（B-Tree）
B-Tree是为磁盘等外存储设备设计的一种平衡查找树

系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。
InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB

```
mysql> show variables like 'innodb_page_size';
```
	
系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB
InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，
这将会减少磁盘I/O次数，提高查询效率。
B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。

描述B-Tree，首先定义一条记录为一个二元组[key, data] ，
key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。

每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。
两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。

子节点结构
- pointer	指针	所在磁盘块的地址
- key		键值	对应表中的主键值
- data	    数据 	除主键外的数据

![3阶的B-Tree结构图](../img/3-B-Tree.png) 

## B+Tree
B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。
而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，
当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。

在B+Tree中，所有**数据记录节点都**是按照键值大小**顺序**存放在同一层的叶子节点上，
而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

* 文件夹与文件

B+Tree相对于B-Tree有几点不同：
1. 非叶子节点只存储键值(key)信息
2. 所有叶子节点之间都有一个链指针
3. 数据记录都存放在叶子节点中

![3阶的B+Tree结构图](../img/3-B+Tree.png) 

## links
* [快速理解平衡二叉树、B-tree、B+tree、B*tree ](https://my.oschina.net/u/3370829/blog/1301732)
* [BTree和B+Tree详解](https://www.cnblogs.com/vianzhang/p/7922426.html)