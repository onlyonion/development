

## 并发控制
### 封锁协议
三级加锁协议也称为三级封锁协议，是为了保证正确的调度事务的并发操作，事务在对数据库对象加锁、解锁是必须遵守的一种规则。
例如何时申请X锁或S锁、持锁时间、何时释放等。称这些规则为封锁协议（Locking Protocol）。

#### 一级封锁协议
事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。

可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。

在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。

#### 二级封锁协议
一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后方可释放S锁。

防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。

#### 三级封锁协议
一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。

防止了丢失修改和不读“脏”数据外，还进一步防止了不可重复读。

主要区别在于什么操作需要申请封锁，以及何时释放。

|              | 锁                  | 隔离级别 | 丢失修改 | 脏读     | 不可重复读 |
| :----------- | :------------------ | :------- | :------- | :------- | :--------- |
| 一级封锁协议 | X                   | 读未提交 | 防止     | 不能防止 | 不能防止   |
| 二级封锁协议 | X + S，读完后释放S  | 读已提交 | 防止     | 防止     | 不能防止   |
| 三级封锁协议 | X + S，事务结束释放 | 可重复读 | 防止     | 防止     | 防止       |

### 共享 (S) 锁
共享 (S) 锁允许并发事务读取 (SELECT) 一个资源。资源上存在共享 (S) 锁时，任何其它事务都不能修改数据。

### 更新锁
更新 (U) 锁可以防止通常形式的死锁。
一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享 (S) 锁，然后修改行，此操作要求锁转换为排它 (X) 锁。

### 排它锁
排它 (X) 锁可以防止并发事务对资源进行访问。其它事务不能读取或修改排它 (X) 锁锁定的数据。

### 意向锁
意向锁表示 SQL Server 需要在层次结构中的某些底层资源上获取共享 (S) 锁或排它 (X) 锁。
例如，放置在表级的共享意向锁表示事务打算在表中的页或行上放置共享 (S) 锁。
在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它 (X) 锁。

意向锁可以提高性能，因为 SQL Server 仅在表级检查意向锁来确定事务是否可以安全地获取该表上的锁。
而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。

意向锁包括意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。

### 架构锁
执行表的数据定义语言 (DDL) 操作（例如添加列或除去表）时使用架构修改 (Sch-M) 锁。

### 大容量更新锁
当将数据大容量复制到表，且指定了 TABLOCK 提示或者使用 sp_tableoption 设置了 table lock on bulk 表选项时，将使用大容量更新 (BU) 锁。
大容量更新 (BU) 锁允许进程将数据并发地大容量复制到同一表，同时防止其它不进行大容量复制数据的进程访问该表。