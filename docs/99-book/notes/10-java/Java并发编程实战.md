《Java并发编程实战》童云兰 译

## 第1章 简介

# 第一部分基础知识
## 第2章 线程安全性
## 第3章 对象的共享
## 第4章 对象的组合
## 第5章 基础构建模块

# 第二部分 结构化并发应用程序
## 第6章 任务执行
## 第7章 取消与关闭
## 第8章 线程池的使用
## 第9章 图形用户界面应用程序

# 第三部分 活跃性、性能与测试
## 第10章 避免活跃性危险
## 第11章 性能与可伸缩性
多个线程引起一些额外的性能开销，线程之间的协调（例如加锁、触发信号以及内存同步等），增加的线程上下文切换，线程的创建和销毁，以及线程的调度等。

应用性能的衡量，“运行速度”，某个特定任务单元需要“多快”才能处理完成；“处理能力”，在资源一定的情况下，能完成“多少”工作。
服务端应用更多关注“多少”，交互式应用程序更关注“多快”。

可伸缩性指的是：当增加计算资源时（例如CPU、内存、存储容量或IO宽带），程序的吞吐量或者处理能力能相应地增加。

### 11.2 Amdahl定律
在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中可**并行组件**与**串行组件**所占的比重。

降低锁的粒度：锁分解（将一个锁分解为两个锁）和锁分段（把一个锁分解为多个锁）。
### 11.3 线程引入的开销
1. 上下文切换 上下文切换导致一些缓存确实，首次调度运行时更加缓慢。
2. 内存同步
    synchronized和volatile提供的可见性保证可能会使用一些特殊指令，即内存栅栏（MemoryBarrier）。
3. 阻塞

### 11.4 减少锁的竞争
!> 在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。

1. 减少锁的范围
2. 减少锁的粒度
3. 锁分段
4. 避免热点域
5. 一些替代独占锁的方法
6. 检测CPU的利用率


## 第12章 并发程序的测试

# 第四部分 高级主题
## 第13章 显示锁
在Java5.0之前，在协调对共享对象的访问时可以使用的机制只有synchronized和volatile。
Java5.0增加了一种新的机制：ReentrantLock。

在Java5.0中，内置锁与ReentranLock相比还有一个优点：在线程转储中能给出在那些调用栈中获得了哪些锁，并能够检测和识别发生死锁的线程。

未来更可能会提升synchronized而不是ReentrantLock的性能。因为synchronized是JVM的内置属性，他能执行一些优化，例如对线程封闭的锁对象的锁消除优化，
通过增加锁的粒度来消除内置锁的同步。

## 第14章 构建自定义的同步工具
## 第15章 原子变量与非阻塞同步机制
## 第16章 Java内存模型