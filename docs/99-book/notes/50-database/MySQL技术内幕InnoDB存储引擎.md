《MySQL技术内幕：InnoDB存储引擎》第2版 姜承尧 机械工业出版社

* 体系结构和存储引擎
* 文件 参数文件、日志文件、套接字文件、pid文件、表结构定义文件、InnoDB文件（表空间文件、重做日志文件）
* 表 索引组织表、逻辑存储结构（表、段、区、页、行）、记录格式、数据页结构、约束、视图、分区表
* 索引与算法 数据结构（二分查找、二叉查找树、平衡二叉树）、B+树、哈希算法、全文检索
* 锁 lock与latch，锁的类型、锁的算法（Record、Gap、Next-key）、锁问题（脏读、不可重复读、丢失更新）、阻塞、死锁、锁升级
* 事务 事务实现、事务控制语句、隔离级别、分布式事务（内部XA事务）、不好的事务习惯、长事务
* 备份与恢复 冷备、逻辑备份、二进制日志备份与恢复、热备、快照备份、复制
* 性能优化 CPU、内存、硬盘、RAID、操作系统、文件系统、基准测试工具

## 第1章 MySQL体系结构和存储引擎
### 1.1 定义数据库和实例
### 1.2 MySQL体系结构
* connectors: native c api, jdbc, odbc, net, php, perl, python, ruby, cobol
* mysql
  * connector pool 连接池
  * management service & utillties
  * sql interface: SQL接口 DML,DDL,Stored Procedures Vies, Triggers, etc.
  * parse: 解析器 Quary Translation Object Privilege
  * optimizer: 优化器 Access Plaths, statistics
  * catches & buffers: 缓存和缓冲 global and engine specific cahces & buffers
* pluggable storage engines 插入式的搜索引擎
  * memory, index & stroage management
* file system; 文件系统 file & logs
  * ntfs, ufs, ext2/3
  * nfs, san, nas

Mysql组成：
* 连接池组件
* 管理服务和工具组件
  * sql接口组件
  * 查询分析器组件
  * 优化器组件
  * 缓冲组件
* 插件式存储引擎
* 物理文件

存储引擎是基于表的，而不是基于数据库。

### 1.3 MySQL存储引擎
每个存储引擎都有各自的特点（策略模式）。
#### 1.3.1 InnoDB存储引擎
支持事务，行锁设计、支持外接。面向OLTP的应用。
多版本并发控制MVCC来获得并发性，并且实现了sql标准的4种隔离级别。
#### 1.3.2 MyISAM存储引擎
不支持事务、表锁设计，支持全文检索，面向OLAP应用。
#### 1.3.3 NDB存储引擎
#### 1.3.4 Memory存储引擎
#### 1.3.5 Archive存储引擎
#### 1.3.6 Federated存储引擎
#### 1.3.7 Maria存储引擎
#### 1.3.8 其他存储引擎
### 1.4 各存储引擎之间的比较
### 1.5 连接MySQL
* TCP/IP
* 命名管道和共享内容
* UNIX域套接字

## 第2章 InnoDB存储引擎
### 2.1 InnoDB存储引擎概述
### 2.2 InnoDB存储引擎的版本
### 2.3 InnoDB体系架构
#### 2.3.1 后台线程
1. Master Thread
2. IO Thread AIO
3. Purge Thread 回收已使用并分配的undo页

#### 2.3.2 内存
1. 缓冲池
2. LRU List、Free List和Fush Lish
   * LRU 最频繁使用的页在LRU列表的前端、最少使用的页在LRU列表的尾端。释放尾端
3. 重做日志缓冲
   
### 2.4 Checkpoint技术
### 2.5 Master Thread工作方式
### 2.6 InnoDB关键特性
### 2.7 启动、关闭与恢复

## 第3章 文件
### 3.1 参数文件
启动配置参数文件，定义某种内存结构有多大等。
### 3.2 日志文件
错误日志、二进制日志、慢查询日志、查询日志
#### 3.2.1 错误日志
#### 3.2.2 慢查询日志
#### 3.2.3 查询日志
#### 3.2.4 二进制日志
### 3.3 套接字文件
### 3.4 pid文件
### 3.5 表结构定义文件
插件式存储引擎。frm为后缀名的文件，记录了该表的表结构定义。
### 3.6 InnoDB存储引擎文件
#### 3.6.1 表空间文件
默认表空间文件，ibdata1，10MB。innodb_data_file_path对其设置。
#### 3.6.2 重做日志文件

## 第4章 表
### 4.1 索引组织表
### 4.2 InnoDB逻辑存储结构
所有的数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。
表空间又由段（segement）、区（extent）、页（page）组成。页在一些文档中有时也被称为块（block）。
* tablespace leaf node segment、Non-Leaf node segement、rollback segment
* segment
* extent
* page
* row

#### 4.2.1 表空间 tablespace
#### 4.2.2 段 segment
表空间是由各个段组成的，常见的段有**数据段**、**索引段**、**回滚段**等。
InnoDB存储引擎表是索引组织的（index organized），因此数据即索引，索引即数据。
那么数据段即为B+树的页节点（上图的leaf node segment），索引段即为B+树的非索引节点（上图的non-leaf node segment）。

#### 4.2.3 区 extent
区是由连续页组成的空间，在任何情况下每个区的大小都为`1MB`。
为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4-5个区。
在默认情况下，页的大小为16KB，即一个区中一共有64个连续的页。

#### 4.2.4 页 page/block
页是InnoDB磁盘管理的最小单位。在InnoDB存储引擎中，默认每个页大小为`16KB`。
从InnoDB 1.2.x版本开始，可以通过参数innodb_page_size将页的大小设置为4K、8K、16K。

常见的页类型有：
* 数据页
* undo页
* 系统页
* 事务数据页
* 插入缓冲位图页
* 插入缓冲空闲列表页
* 未压缩的二进制大对虾页
* 压缩的二进制大对象页

#### 4.2.5 行 row
InnoDB是面向列的（row-oriented），数据是按行进行存放的。
每个页存放的行记录也是有硬性定义的，最多允许存放`16KB/2 - 200`行的记录，即`7992`行记录。

面向列的数据库，google big table。

##### 物理存储结构
从物理意义上来看，InnoDB表由共享表空间、日志文件组（更准确地说，应该是Redo文件组）、表结构定义文件组成。
若将innodb_file_per_table设置为on，则每个表将独立地产生一个表空间文件，以ibd结尾，数据、索引、表的内部数据字典信息都将保存在这个单独的表空间文件中。
表结构定义文件以frm结尾，这个是与存储引擎无关的，任何存储引擎的表结构定义文件都一样，为.frm文件。

### 4.3 InnoDB行记录格式
### 4.4 InnoDB数据页结构
### 4.5 Named File Formats机制
### 4.6 约束
#### 4.6.1 数据完整性
#### 4.6.2 约束的创建和查找
#### 4.6.3 约束和索引的区别
约束更是一个逻辑的概念，用来保证数据的完整性，索引是一个数据结构，既有逻辑上的概念，在数据库中还代表这物理存储方式。
#### 4.6.4 对错误数据的约束
#### 4.6.5 ENUM和SET约束
#### 4.6.6 触发器与约束
#### 4.6.7 外键约束
一般来说，称被引用的表为父表，引用的表成为子表。
### 4.7 视图
### 4.8 分区表
分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上将，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。  
MySQL数据库支持的分区类型为水平分区（同一个表中不同的**行**的记录分配到不同的物理文件中），不支持垂直分区（同一个表中不同的**列**的记录分配到不同的物理文件中）。
#### 4.8.5 分区和性能
数据库的应用分为两类：
* OLTP（在线事务处理） Blog、电子商务、网络游戏等 分区需要小心
* OLAP（在线分析处理） 数据仓库、数据集市 分区可提高查询性能

## 第5章 索引与算法
### 5.1 InnoDB存储引擎索引概述
B+树索引 B 代表 平衡balance，而不是二叉binary。
### 5.2 数据结构与算法
#### 5.2.1 二分查找法
又称拆半查找法。基本思想：将记录按有序化排序，在查找过程中采用跳跃式查找。
#### 5.2.2 二叉查找树和平衡二叉树
### 5.3 B+树
B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树。
所有记录节点**按照键值大小顺序**存放在同一层的**叶子节点**上，由各叶子节点指针进行连接。
#### 5.3.1 B+树的插入操作
三种情况
1. leaf page不满、index page不满
2. leaf page满、index page不满
3. leaf page满、index page满

拆分页操作 -> 旋转

#### 5.3.2 B+树的删除操作
使用填充因子来控制树的删除变化。

### 5.4 B+树索引
B+树索引在数据库中有一个特点是高扇出性，在数据库中，B+树的高度一般都是2-4层，查找某一行记录最多只需要2-4次IO。
聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。
#### 5.4.1 聚集索引
实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。

索引组织表，基于primary key**自动生成**的索引，效率极高。
#### 5.4.2 辅助索引
对于辅助索引（也称非聚集索引），叶节点**不包含**行的全部数据。

辅助索引的存在并不影响数据在聚集索引中的组织。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后通过主键索引来找到一个完整的行记录。
#### 5.4.3 B+树索引的分裂
#### 5.4.4 B+树索引的管理

### 5.5 Cardinality值
查看索引是否是高选择性，show index，cardinality表示索引中不重复记录的预估值。
### 5.6 B+树索引的使用
#### 5.6.1 不同应用中B+树索引的使用
#### 5.6.2 联合索引
联合索引也是一颗B+树，不同的是联合索引的键值的数量不是1，而是大于等于2.
```sql
key idx_a_b(a, b)
// 走索引
select * from table where a='x'; 
select * from table where a='x' and b='y';
// 不走索引
select * from table where b='y';
```
联合索引的第二个好处是已经对**第二个键值进行了排序处理**。取a等值查询，然后按照b排序，使用联合索引可以避免多一次的排序操作。
#### 5.6.3 覆盖索引
covering index，从辅助索引中就可以**得到查询的记录**，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。
#### 5.6.4 优化器选择不使用索引的情况
#### 5.6.5 索引提示
#### 5.6.6 Multi-Range Read优化
#### 5.6.7 Index Condition Pushdown（ICP）优化
### 5.7 哈希算法
时间复杂度`O(1)`，且不只存在于索引中，每个数据库应用中都存在该数据结构。
#### 5.7.1 哈希表
哈希表也称散列表，由直接寻址表改进而来。
哈希碰撞、哈希冲突，在数据库中一般用**链接法**解决，把散列到同一槽中的所有元素都放在一个链表中。

数据库一般采用除法散列的方法，`h(k) = k mod m`

#### 5.7.2 InnoDB存储引擎中的哈希算法
#### 5.7.3 自适应哈希索引
自适应哈希索引经哈希函数映射到一个哈希表中，因此对于字典类型的查找非常快速，但对于范围查找无能为力。
* 哈希索引只能用来搜素等值的查询。

### 5.8 全文检索
#### 5.8.1 概述
全文检索（Full-Text Search）是将存储在数据库中的整本书或整篇文章中的任意内容信息查找出来的计算。

从InnoDB 1.2.x版本开始，支持全文索引。
#### 5.8.2 倒排索引
全文索引通常使用倒排索引实现，它在辅助表中存储了单词与单词自身在一个或多个文档中所在的位置之间的映射，通常通过关联数组实现。两种表现形式：
* inverted file index，表现形式 {单词，单词所在文档的ID}
* full inverted index，表现形式 {单词，（按此所在文档的ID，在具体文档中的位置）}

#### 5.8.3 InnoDB全文检索
采用full inverted index方式。在InnoDB存储引擎中，将`(DocumentId, Position)`视为一个`ilist`。
因此在全文检索的表中，有两个列，一个是`word`字段，另一个是`ilist`字段，并且在word字段上设为索引。

倒排索引需要将word字段存放在一张表中，这个表称为AuxiliaryTable（辅助表）。
在InnoDB中，为了提高全文检索的并行性能，共有6张AuxiliaryTable，目前每张表根据word的Latin编码进行分区。

Auxiliary Table是持久的表，存放在磁盘上。
FTS Index Cache（全文检索索引缓存），用来提高全文检索的性能。FTS Index Cache是一个红黑树结构，其根据（word，list）进行排序。
这意味着插入的数据已经更新了对应的表，但是对全文索引的更新可能在分词操作后还在FTS Index Cache中，AuxiliaryTable可能还没有更新。

#### 5.8.4 全文检索

## 第6章 锁
### 6.1 什么是锁
锁机制用于管理对**共享资源**的并发访问，提供数据的**完整性和一致性**。
操作缓冲池中的LRU列表，删除、添加、移动LRU列表的元素，为了保证一致性，必须有锁的介入。

### 6.2 lock与latch
### 6.3 InnoDB存储引擎中的锁
#### 6.3.1 锁的类型
InnoDB实现了如下两种标准的**行级锁**：
- 共享锁 S Lock 允许事务读一行数据
- 排它锁 X Lock 允许事务删除或更新一行数据

意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。
若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。
- 意向共享锁 IS Lock 事务想要获得一张表中某几行的共享锁
- 意向排它锁 IX Lock 事务想要获得一张表中某几行的排它锁

#### 6.3.2 一致性非锁定读
一致性非锁定读是指InnoDB存储引擎通过**行多版本控制**的方式读取当前执行时间数据库中行的数据。

非锁定读，因为不需要等待访问上X锁的释放。快照数据是指改行的之前版本的数据。该实现是通过undo段来完成的。

非锁定读机制级大地提高了数据库的并发性。
一个行记录可能不止有一个快照数据，一般称这种技术为多版本技术。由此带来的并发控制，称之为多版本并发控制（MVCC）。

#### 6.3.3 一致性锁定读
在某些情况下，即使是对于select的只读操作，也要加锁。支持两种一致性锁定读。
- `select ... for update` 对读取的行记录加一个X锁。
- `select ... lock in share lock` 对读取的航迹路加一个S锁。其他事务可以想被锁定的行加S锁，但是如果加X锁，则会被阻塞。

#### 6.3.4 自增长与锁

### 6.4 锁的算法
#### 6.4.1 行锁的3种算法
1. `Record Lock`：记录锁，单个行记录上的锁（粒度小、系统开销大、并发性能高）
2. `Gap Lock`：间隙锁，锁定一个范围，但是不包括记录本身
3. `Next-Key Lock`：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身（粒度大、系统开销小、并发性能低）
   
NextKeyLock，设计目的是为了解决PlantomProblem，锁定的不是单个值，而是一个范围，是谓词锁的一种改进。
当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-KeyLock进行优化，将其降级为RecordLock，仅锁住索引本身，而不是范围。提高应用的并发性。

- 唯一索引，Next-Key Lock 降级为Record Lock
- 辅助索引，仍然是Next-Key Lock，并且还会对辅助索引下一个键值加上gap lock。

!> Gap Lock的作用是为了阻止多个事务将记录插入到**同一个范围**，而这会导致**幻读**问题的产生。

显示地关闭gap lock
- 事务隔离级别设置为 read committed
- 参数innodb_lock_unsafe_for_binlog设置为1

#### 6.4.2 解决Phantom Problem
在默认的事务隔离级别下（Repeatable Read），InnoDB存储引擎采用Next-Key Locking机制来避免Phantom Problem。

Phantom Problem是指在同一事务下，连续执行两次同样的Sql语句可能导致不同的结果，第二次的sql语句可能会返回之前不存在的行。

### 6.5 锁问题
#### 6.5.1 脏读
脏数据是指事务对缓冲池中行记录的修改，并且还没有被提交（commit）。违背了事务的隔离性。   
脏读指的就是在不同的事务下，当前事务可以读到另外事务未提交的数据，简单来说就是可以读到脏数据。
#### 6.5.2 不可重复读
不可重复读是指在一个事务内多次读取同一数据集合。在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作。

脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但是违背了数据库事务一致性的要求。
#### 6.5.3 丢失更新
> 丢失更新时另一个锁导致的问题，简单来说就是一个事务的更新操作会被另一个事务的更新操作锁覆盖，从而导致数据的不一致。  

避免丢失更新发生，需要让事务在这种情况下的操作变成**串行化**，而不是并行操作。
```sql
select cash from account where user = puser for update;
update account set cash=@cash-9 where user = puser;
```
### 6.6 阻塞
> 因为不同锁之间的兼容关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放他所占用的资源，这就是阻塞。

阻塞并不是一件坏事，其是为了确保事务可以**并发**且**正常**地运行。

### 6.7 死锁
> 死锁是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象。

解决死锁问题最简单的一种方法是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值，
其中一个事务进行回滚，另一个等待的事务就能够继续进行。
### 6.8 锁升级
锁升级是指当前锁的**粒度降低**。多个行锁升级为一个页锁，或将页锁升级为表锁。

行锁 -> 页锁 -> 表锁。这种升级保护了系统资源，防止系统使用太多的内存来维护锁，在一定程度上提高了效率。

PS：Java中自旋锁、偏向锁、轻量级锁、重量级锁、锁粗化、锁消除

## 第7章 事务
事务是数据库区别与文件系统的重要特性之一。文件系统在写文件，但是操作系统突然崩溃，有可能损坏。

引入事务的目的：事务会把数据库从一种一致状态转换为另一种一致状态。

### 7.1 认识事务
#### 7.1.1 概述
虽然理论定义了严格的事务要求，但是数据库厂商出于各种目的，并没有严格去满足事务ACID的标准。
* 原子性
* 一致性 事务将数据库从一种状态转变为下一种一致的状态。完整性约束不会被破坏。如唯一约束。
* 隔离性 其他称呼，并发控制、可串行化、锁。一个事务提交前对其他事务都不可见。
* 持久性 一旦提交，结果是永久性的。即使宕机也能恢复。若RAID卡损坏、自然灾害等外部原因，仍可能丢失。

#### 7.1.2 分类
1. 扁平事务 所有的操作处于同一层次。限制是不能提交或者回滚事务的某一部分。
2. 带有保存点的扁平事务 支持有计划的回滚操作。
3. 链事务 保存点模式的变种，带有保存点的事务，发生系统崩溃时，所有的保存点会消失。
4. 嵌套事务 层次结构的事务。顶层事务控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务，控制着每一个局部变更。
5. 分布式事务 分布式环境下的扁平事务。

### 7.2 事务的实现
!> 事务的隔离性是由`锁`实现。原子性、一致性、持久型通过数据库的`redo log`和`undo log`来完成。
redo log称为重做日志，用来保证事务的原子性和持久性。undo log用来保证事务的一致性。

#### 7.2.1 redo
重做日志用来实现事务的持久性。由两部分组成：
- 一是内存中的重做日志缓冲（redo log buffer），是易失的；
- 二是重做日志文件（redo log file），是持久的。

为了确保每次日志都写入重做日志文件，在每次将重做日志缓冲写入重做日志文件后，InnoDB存储引擎都要调用一次fsync操作。
由于fsync的效率取决于磁盘的性能，因此磁盘的性能决定了事务提交的性能，也就是数据库的性能。

在Inno存储引擎中，重做日志都是以512字节进行存储的。这意味着重做日志缓冲、重做日志文件都是以块（block）的方式进行保存的。

#### 7.2.2 undo
重做日志记录了事务的行为，可以很好地通过对其页进行“重做”操作。但是事务有时还需要进行回滚操作，这时就需要undo。
因此在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。

undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有的修改都被逻辑的取消了，但是数据结构和页本身在回滚之后可能大不相同。

#### 7.2.3 purge
delete和update操作可能并不直接删除原有数据。

purge用于最终完成delete和update操作。这样设计时因为InnoDB存储引擎支持MVCC，所以记录不能再事务提交时立即进行处理。

#### 7.2.4 group commit
为了提高磁盘fsync的效率，当前数据库都提供了group commit的功能，即一次fsync可以刷新确保多个事务日志被写入文件。
对于InnoDB存储引擎来说，事务提交时会进行两个阶段的操作，
1. 修改内存中事务对应的信息，并且将日志写入重做日志缓冲。
2. 调用fsync将确保日志从重做日志缓冲写入磁盘。（较慢）

MySQL5.6的BinaryLogGroupCommit（BLGC）的实现方式是将事务提交的过程分为几个步骤来完成。
上层进行提交时首先按顺序将其放入一个队列中，队列中的第一个事务成为leader，其他事务成为follower，leader控制这follower的行为。
- flush阶段，将每个事务的二进制日志写入内存中
- sync阶段，将内存中的二进制日志刷新到磁盘，若队列中有多个事务，那么近一次fsync操作就完成了二进制日志的写入
- commit阶段

### 7.3 事务控制语句
### 7.4 隐式提交的SQL语句
### 7.5 对于事务操作的统计
- 每秒请求数（QPS），
- 每秒事务处理能力（TPS），

### 7.6 事务的隔离级别
隔离级别越低，事务请求的锁**越少**或保持锁的**时间就越短**。这是为什么大多数据库的默认事务隔离级别是READ COMMITED。

repeatedable read与serializable的性能开销几乎一样，read commited性能也不会大幅度提升。
### 7.7 分布式事务
#### 7.7.1 MySQL数据库分布式事务
XA事务由一个或多个资源管理器（Resource Managers）、一个事务管理器（Transaction Manager）以及一个应用程序（Application Program）组成。
* 资源管理器 提供访问事务资源的方法。通常一个数据库就是一个资源管理器。
* 事务管理器 协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。
* 应用程序 定义事务的边界，指定全局事务中的操作。

#### 7.7.2 内部XA事务
MySQL数据库中的另外一种分布式事务，在存储引擎与插件之间，又或者在存储引擎与存储引擎之间，称之为内部XA事务。
binlog与InnoDB存储引擎之间。

### 7.8 不好的事务习惯
### 7.9 长事务
执行时间较长的事务。有时可以转化为小批量（mini batch）的事务来进行。

## 第8章 备份与恢复
### 8.1 备份与恢复概述
### 8.2 冷备
### 8.3 逻辑备份
### 8.4 二进制日志备份与恢复
### 8.5 热备
### 8.6 快照备份
### 8.7 复制
复制不是完全实时地进行同步，而是异步实时。如果主库眼里很大，则可能导致主从服务器延时较大。

建议在从服务上启用read-only选项，保证从服务器上的数据仅与主服务器进行同步，避免其他线程修改数据。

## 第9章 性能调优
### 9.1 选择合适的CPU
OLTP是IO密集型的操作，OLAP是CPU密集型的操作。
### 9.2 内存的重要性
InnoDB存储引擎既缓存数据，又缓存索引，并将它们缓存于一个很大的缓冲池中，InnoDB Buffer Pool。
### 9.3 硬盘对数据库性能的影响
#### 9.3.1 传统机械硬盘
机械硬盘的指标，寻道时间，转速。
#### 9.3.2 固态硬盘
### 9.4 合理地设置RAID
### 9.5 操作系统的选择
### 9.6 不同的文件系统对数据库性能的影响
### 9.7 选择合适的基准测试工具
#### 9.7.1 sysbench
#### 9.7.2 mysql-tpcc

## 第10章 InnoDB存储引擎源代码的编译和调试