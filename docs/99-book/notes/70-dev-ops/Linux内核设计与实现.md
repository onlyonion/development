《Linux内核设计与实现》[美]Robert Love著 陈莉君 康华 译

* `进程管理（进程与线程、调度、同步、死锁）`
  * 内核、进程管理、进程调度、系统调用、内核数据结构
  * 中断和中断处理、下半部和推后执行的工作
  * 内核同步介绍、内核同步方法、定时器和时间管理
* `内存管理（覆盖交换、分配、虚拟内存管理）`
  * 内存管理、进程地址空间
  * 页高速缓存和页回写
* `文件管理（文件、目录、共享、保护、层次结构、磁盘组织与管理）`
  * 虚拟文件系统
* `IO管理（设备、控制方式、层次结构、调度、高速缓存与缓冲区、分配与回收）`
  * 块I/O层
  * 设备与模块
* 调试、可移植性、补丁、开发和社区

## 第1章 Linux内核简介
Torvalds李纳斯·托沃兹, linux之父，全名Linus Benedic Torvalds ，是一位出生于1969.12.28的芬兰人。
### 1.3 操作系统和内核简介 
操作系统就是指在整个系统中负责完成最基本功能和系统管理的部分，内核、设备驱动程序、启动引导程序、命令行Shell
或其他种类的用户界面、基本的文件管理工具和系统工具。  

应用程序通过**系统调用**与内核通信。  

中断机制。当硬件设备想和系统通信的时候，它首先要发出一个异步的中断信号去打断处理器的执行，继而打断内核的执行。
中断通常对应着一个中断号，内核通过这个中断号去查找相应的中断服务程序，并调用这个程序相应和处理中断。

### 1.4 Linux内核和传统Unix内核的比较

微内核并不作为一个单独的大过程来实现。相反，微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。
所有的服务器都保持独立并运行在各自的地址空间上。
不可能像单模块内核那样直接调用函数，通过消息传递处理机制来理解微内核通信：系统采用了进程间通信（IPC）机制。


## 第2章 从内核出发 
### 2.1 获取内核源码
http://www.kernel.org
```sh
git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
```
### 2.2 内核源码树

| 目录          | 描述                             |
|:--------------|:-------------------------------|
| arch          | 特定体系结构的源码               |
| block         | 块设备I/O层                      |
| crypto        | 加密API                          |
| Documentation | 内核源码文档                     |
| drivers       | 设备驱动程序                     |
| firmware      | 使用某些驱动程序而需要的设备固件 |
| fs            | VFS和各种文件系统                |
| include       | 内核头文件                       |
| init          | 内核引导和初始化                 |
| ipc           | 进程间通信代码                   |
| kernel        | 像调度程序这样的核心子系统       |
| lib           | 通用内核函数                     |
| mm            | 内存管理子系统和VM               |
| net           | 网络子系统                       |
| samples       | 示例 示范代码                    |
| scripts       | 编译内核所用的脚本               |
| security      | Linux安全模块                    |
| sound         | 语音子系统                       |
| usr           | 早期用户空间代码                 |
| tools         | 工具                             |
| virt          | 虚拟化基础结构                   |

### 2.4 内核开发的特点
#### 2.4.1 无libc库抑或无标准头文件 
#### 2.4.2 GNUC 
#### 2.4.3 没有内存保护机制 
#### 2.4.4 不要轻易在内核中使用浮点数 
#### 2.4.5 容积小而固定的栈 
#### 2.4.6 同步和并发 
* 抢占式多任务操作系统
* 支持对称多处理器
* 中断是异步到来的
* 内核可以抢占  
解决办法自旋锁和信号量

#### 2.4.7 可移植性的重要性 

## 第3章 进程管理 
### 3.1 进程
进程就是处于执行期的程序一起相关的资源的总称。程序代码本身不是进程。  
执行线程，简称线程，是在进程中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。 
内核调度的对象是线程，而不是进程。Linux系统对线程和进程并不特别区分，线程只不过是一种特殊的进程罢了。

进程提供两种虚拟机制：虚拟处理器和虚拟内存。进程是处于执行期的程序以及相关的资源的总称。
进程另一个名字是任务。Linux内核通常把进程也叫做任务。`fork`现有进程创建进程。
### 3.2 进程描述符及任务结构 
内核把进程的列表放在叫做任务列表（task list）的双向循环链表中。链表中的每一个项都是类型为`task_struct`称为
进程描述符（process descriptor）的结构，定义在`<linux/sched.h>`文件中。进程描述符中包含一个具体进程的所有信息。
#### 3.2.1 分配进程描述符
struct thread_info 在文件`<asm/thread_info.h>`中定义
#### 3.2.2 进程描述符的存放
#### 3.2.3 进程状态
#### 3.2.4 设置当前进程状态
#### 3.2.5 进程上下文
#### 3.2.6 进程家族树
### 3.3 进程创建 
### 3.4 线程在Linux中的实现
同一程序内共享内存地址空间运行的一组线程。这些线程可以共享打开的文件和其他资源。
对于Linux来说，它只是一种进程间共享资源的手段。
#### 3.4.1 创建线程
#### 3.4.2 内核线程
### 3.5 进程终结 
#### 3.5.1 删除进程描述符
#### 3.5.2 孤儿进程造成的进退维谷

## 第4章 进程调度 
调度程序负责决定将哪个进程投入运行，何时运行以及运行多长时间。
进程调度程序可看做在可运行状态进程之间分配有限的处理器时间自由的内核子系统。  
在一组处于可运行状态的进程中**选择**一个来执行，是调度程序所需完成的基本工作。
### 4.1 多任务
非抢占式多任务、抢占式多任务
### 4.2 Linux的进程调度
### 4.3 策略
#### 4.3.1 I/O消耗型和处理器消耗型的进程 
#### 4.3.2 进程优先级
#### 4.3.3 时间片
#### 4.3.4 调度策略的活动
### 4.4 Linux调度算法
#### 4.4.1 调度器类
调度器是以模块方式提供的。
这种模块化的结构被称为调度器类（scheduler classes），它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。
`kernel/sched.c`
#### 4.4.2 Unix系统中的进程调度
#### 4.4.3 公平调度
上下文切换资源消耗，影响缓存的效率。
### 4.5 Linux调度算法实现
#### 4.5.1 时间记账
CFS使用调度器实体结构（`<linux/sched.h>`的`struct_sched_entity`）来追踪进程运行记账。
#### 4.5.2 进程选择
CFS使用红黑树来组织可**运行进程队列**。
#### 4.5.3 调度器入口
进程调度的入口点是函数`schedule()`，定义在`kernel/sched.c`中。选择哪个进程可以运行，何时将其投入运行。
#### 4.5.4 睡眠和唤醒
1. 等待队列
2. 唤醒

### 4.6 抢占和上下文切换
上下文切换，就是从一个可执行的进程切换到另一个可执行的进程，由定义在`kernel/sched.c`中的`context_swtich()`函数复制处理。
### 4.7 实时调度策略
### 4.8 与调度相关的系统调用

## 第5章 系统调用 
### 5.1 与内核通信
为用户空间提供了一种硬件的抽象接口。系统调用确保证了系统的稳定和安全。是用户空间访问内核的唯一手段。
### 5.2 API、POSIX和C库
### 5.3 系统调用
syscal
### 5.4 系统调用处理程序
用户空间的程序无法直接执行内核代码。应用程序以软中断的机制通知系统，需要执行系统调用，希望系统切换到内核态。
### 5.5 系统调用的实现
### 5.6 系统调用上下文

## 第6章 内核数据结构 
### 6.1 链表 
* 单向链表和双向链表
* 环形链表
* 沿链表移动
* Linux内核中的实现
* 操作链表
* 遍历链表
  
### 6.2 队列
编程模型：生产者和消费者。使用队列实现。
* kfifo 实现在`kernel/kfifo.c`，声明在`<linux/kfifo.h>`
* 创建队列 kfifo_alloc
* 推入队列数据
* 摘取队列数据
* 获取队列长度
* 充值和撤销队列

### 6.3 映射 
关联数组、字典、哈希表、散列表

### 6.4 二叉树
#### 6.4.1 二叉搜索树BST
是一个节点有序的二叉树
* 根的左分支节点值都小于根节点值
* 右分支节点值都大于根节点值
* 所有的子树也都是二叉搜索树

#### 6.4.1 自平衡二叉搜索树
深度差不超过1的二叉搜索树。一个节点的深度是指从根节点起，到达它一共需经过的父节点数目。

红黑树 
* 所有的节点要么着红色，要么着黑色
* 叶子节点都是黑色
* 叶子节点不包含数据
* 所有非叶子节点都有两个子节点
* 如果一个节点是红色，则它的子节点都是黑色
* 在一个节点到其他叶子节点的路径中，如果总是包含同样数目的黑色节点，则改路径相比其他路径是最短的。

上述条件，保证最深的叶子节点的深度不会大于两倍的最浅叶子节点的深度

rbtree linux实现的红黑树称为日本tree，`lib/rbtree.c`，声明在`<linux/rbtree.h>`中。

### 6.5 数据结构以及选择
* 主要操作是遍历数据，使用链表
* 符合生产者/消费者模式，使用队列
* 一个UID到一个对象，使用映射
* 存大量数据，并且检索迅速，使用红黑树
* 基树和位图

### 6.6 算法复杂度 
渐进行为是指当算法的输入变得非常大或接近于无限大时算法的行为。


## 第7章 中断和中断处理
!> 那么到底如何让处理器和这些外部设备能协同工作，且不会降低机器的整体性能呢？
轮询（polling）可能是一种解决方法。更好的办法是又我们提供一种机制，让硬件在需要的时候再向内核发出信号，这就是中断机制。

### 7.1 中断
硬件 -->  处理器 --> 操作系统

中断使得硬件得益发出**通知**给处理器。中断本质上是一种特殊的电信号，由由硬件设备发向处理器。
处理器一经检测到中断信号，便中断自己的当前工作转而处理中断。此后，处理器会通知操作系统已经产生中断。

硬件设备生成中断的时候并不考虑与处理器的时钟同步，中断随时可以产生。

异常，与中断不同，它在产生时必须考虑处理器时钟同步。
### 7.2 中断处理程序
### 7.3 上半部分与下半部分的对比
中断处理程序是上半部分，接收到一个中断，它就立即开始执行，但只做有严格时限的工作。
能够被允许稍后完成的工作会推迟到下半部分。

### 7.4 注册中断处理程序 
### 7.5 编写中断处理程序 
### 7.6 中断上下文 
### 7.7 中断处理机制的实现 
### 7.8 /proc/interrupts 
procfs是一个虚拟文件系统，它只存在与内核内存，一般安装与/proc目录。
/proc/interrupts文件，系统中雨中断相关的统计信息。

### 7.9 中断控制 

## 第8章 下半部和推后执行的工作 

## 第9章 内核同步介绍
共享资源防止并发访问，防止数据不一致状态。
### 9.1 临界区和竞争条件
所谓临界区就是访问和操作共享数据的**代码段**。
避免并发和防止竞争条件成为同步。
### 9.2 加锁 
用户控件之所以需要同步，是因为用户程序会被**调度程序抢占和重新调度**。
### 9.3 死锁 
### 9.4 争用和扩展性 

## 第10章 内核同步方法 
### 10.1 原子操作 
### 10.2 自旋锁 
自旋锁的时间最好小于完成两次上下文切换的耗时。自旋锁应尽可能的短。
`<asm/spinlock.h>` `<linux/spinlock.h>`
自旋锁是不可递归的。
需要**保护的是数据**而不是代码。

### 10.3 读一写自旋锁 
### 10.4 信号量 
### 10.5 读一写信号量 
### 10.6 互斥体 
### 10.7 完成变量 
### 10.8 BLK：大内核锁 
### 10.9 顺序锁 
### 10.10 禁止抢占 
### 10.11 顺序和屏障 

## 第11章 定时器和时间管理 

## 第12章 内存管理 
### 12.1 页 
内核把物理页作为内存管理的基本单位。内存管理单元（MMU，管理内存并把虚拟地址转换为物理地址的硬件）

```c
// <linux/mm_types.h>
struct page {
    unsigned long flags;
    atomic_t _count;
    atomic_t _mapcount;
    unsigned long private;
    struct address_space *mapping;
    pgoff_t index;
    struct list_head lru;
    void *virtual;
}
```

### 12.2 区 
由于硬件的限制，内核并不能对所有的页一视同仁。内核把页划分为不同的区（zone）。

* ZONE_DMA
* ZONE_DMA32
* ZONE_NORMAL
* ZONE_HIGMEM  

Linux把系统的页划分为区，形成不同的内存池，这样就可以根据用途进行分配了。

### 12.3 获得页 
```c
struct page * alloc_pages(gfp_t gfp_mask, unsigned int order)
```

### 12.4 kmalloc()
```c
/**
 * @param size
 * @param flags
 * @return 返回一个指向内存块的指针，其内存块至少要有size大小
 *        所分配的内存在物理上是连续的
 */
void * kmalloc(size_t size, gfp_t flags)

void kfree(const void *ptr)
```

### 12.5 vmalloc()
分配的内存虚拟地址是连续的，物理地址无须连续。

### 12.6 slab层 
### 12.7 在栈上的静态分配 
### 12.8 高端内存的映射 
### 12.9 每个CPU的分配 
### 12.10 新的每个CPU接口 
### 12.11 使用每个CPU数据的原因 
### 12.12 分配函数的选择 

## 第13章 虚拟文件系统 
### 13.1 通用文件系统接口 
### 13.2 文件系统抽象层 

## 第14章 块I/O层 
系统中能够随机（不需要按顺序）访问固定大小数据片（chunks）的硬件设备称作块设备。
固定大小的数据片称作块。

## 第15章 进程地址空间
用户空间进程的内存，称为进程地址空间。Linux使用虚拟内存技术，所有进程间以虚拟方式共享内存。
### 14.1 剖析一个块设备 
### 14.2 缓冲区和缓冲区头 
### 14.3 bio结构体 
### 14.4 请求队列 
### 14.5 I/O调度程序 

## 第16章 页高速缓存和页回写 
## 第17章 设备与模块 
## 第18章 调试 
## 第19章 可移植性 
## 第20章 补丁、开发和社区 