《逆流而上 阿里巴巴技术成长之路》

* 典型“踩坑”案例
* 基础架构、 中间件、 数据库、 云计算、 大数据等技术领域

## 第1章 基础架构高可用
### 1.1 明察秋毫， 域名解析排查技巧
### 1.2 智能定位， 网络端到端静默丢包点迅速锁定
### 1.3 灵活调度， 对接运营商网络流量的容灾策略
### 1.4 抽丝剥茧， 深挖云盘挂起背后的真相
### 1.5 存储的底线， SSD数据不一致

## 第2章 中间件使用常见隐患与预防
### 2.1 高并发“热点”缓存数据快速“退火”
### 2.2 自我保护， 让系统坚如磐石
### 2.3 机房容灾， VIPServer软负载流量调度实例
### 2.4 山洪暴发， 高流量触发Tomcat bug引起集群崩溃
Tomcat三种连接器模式，BIO/NIO/APR/NIO2。NIO的模式：
* Acceptor线程 接受请求，轮询分发事件到Poller
* Poller线程 维护PollerEvent事件队列，拿出Socket，注册到自己的selector，等待selector选择读写事件，构造SocketProcessor
* SocketProcessor线程

## 第3章 数据库常见问题
### 3.1 性能杀手， SQL执行计划
### 3.2 波谲云诡， 数据库延迟
### 3.3 风暴来袭， AliSQL连接池调优
### 3.4 防患于未然， ORM规约变更案例
### 3.5 云数据库， SQL优化经典案例

## 第4章 业务研发经典案例
### 4.1 幂等控制， 分布式锁超时情况和业务重试的并发
### 4.2 另类解法， 分布式一致性
### 4.3 大道至简， 从故障模型的边界状态切换到原始状态
### 4.4 疑案追踪， JSON序列化不一致
### 4.5 从现象到本质， 不保证顺序的Class.getMethodsJVM实现
### 4.6 破解**超时**迷局， 浅析启动初期load飙高问题
业界JVM多使用混合执行模式， 其执行过程按照如下步骤。
1. 解释执行： 在应用启动之后， 方法以解释执行方式执行。
2. 触发JIT编译： 当方法执行次数达到JIT编译阀值时（server方式下默认为 10000次， 计数会根据执行时长做衰减， 以防对非热点方法执行JIT编译） 会触发JIT编译。
3. 机器指令方式执行： 编译之后， 此方法以机器指令方式执行， 进而提高执行效率（Tiered compilation， 在编译以后的执行期间， JVM还会根据执行情况对编译后的指令做优化处理， 进而更好地提高执行效率） 。

此种方式本没有问题， 可是当应用调用量很大时， 大量请求同时进入，多个方法同时促发JIT时， 会出现本文中上述提到的启动初期load飙高， 进而导致服务超时的问题。 

### 4.7 洞悉千丝万缕， 浅谈JIT编译优化的误区
在JDK7里不要使用-XX:+TieredCompilation来缓解应用重启过程中，JIT 编译导致的 CPU 使用率达 100%的问题， 可以通过提前代码预热或增加应用容量来解决。<br/>
设置JVM参数`-XX:ReservedCodeCacheSize=256MB`， 防止应用出现因为CodeCache空间不足导致的问题

## 第5章 运行管理域稳定性建设
### 5.1 洞若观火， 让故障无处遁形
### 5.2 体系化思考， 高效解决运营商问题
### 5.3 以战养兵， 以故障演练提升系统稳定性