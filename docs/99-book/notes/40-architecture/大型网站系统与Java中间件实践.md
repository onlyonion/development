《大型网站系统与Java中间件实践》曾宪杰

前淘宝技术负责人，2002年毕业于浙江大学计算机系。

* 应用服务 业务拆分、服务化
* 数据存储 读写分离、缓存、分布式存储、搜索引擎、分库分表
* 消息中间件 解耦合、异步

## 第1章 分布式系统介绍
### 1.1 初试分布式系统
#### 1.1.1 分布式系统的定义
> A distributed system is one in which components located at networked computers communicate and coordinate their actions ony by message messages
> ---- Distributed System Concepts and Design (Third Edtion)

组件分布在网络计算机上，组件之间仅仅通过消息传递来协同并协调行动。
* 多节点组成
* 节点之间相互连通
* 消息传递

#### 1.1.2 分布式系统的意义
引入分布式系统的原因
* 升级单机处理能力的性价比越来越低
* 单机处理能力存在瓶颈
* 出于稳定性和可用性的考虑

### 1.2 分布式系统的基础知识
#### 1.2.1 组成计算机的5要素
#### 1.2.2 线程与进程的执行模式
阿姆达尔定律

互不通信的多线程模型

基于共享容器协同的多线程模型

通过事件协同的多线程模型

多进程模型

#### 1.2.3 网络通信基础知识

OSI与TCP/IP网络模型

网络IO实现方式
* BIO方式
* NIO方式 基于事件驱动的思想，采用的是Reactor模式，一个线程中处理多个Socket套接字相关的动作。Reactor管理所有的Handler，并且把出现的事件交给相应的Handler去处理。
* AIO方式 异步IO，采用Proactor模式。

!> NIO在有通知时可以进行相关操作，例如读或者写，而AIO在有通知时表示相关操作已经完成。

#### 1.2.4 如何把应用从单机扩展到分布式
计算机一共由5个部分组成，从使用者的角度来看，分布式系统就像是一个超级计算机。
1. 输入设备的变化
2. 输出设备的变化
3. 控制器的变化 分布式系统是由多个**节点**通过网络连接在一起并通过**消息传递**进行协调的系统。控制器的主要作用就是协调或控制节点之间的动作和行为。
   所有的请求都要经过复制均衡设备来完成请求转发的控制，这就是一种控制的方式。
4. 运算器的变化 分布式系统中，运算器是由多个节点来组成的。运用多个节点的计算能力来协同完成整体的计算任务。
5. 存储器的变化

#### 1.2.5 分布式系统的难点
1. 缺乏全局时钟
2. 面对故障独立性 在分布式系统中，整个系统的一部分有问题而其他部分正常是进程出现的情况，称之为故障独立性。
3. 处理单点故障 整个分布式系统中，如果某个角色或者功能只有某台单机在支撑，那么这个节点称为单点，其发生的故障成为单点故障。
   避免单点的关键就是把这个功能从单机实现变为集群实现。
4. 事务的挑战 ACID，CAP，BASE，Paxos，最终一致。

## 第2章 大型网站及其架构演进过程
### 2.1 什么是大型网站
大型网站是一种分布式系统，数据量、访问量大。
### 2.2 大型网站的架构演进
#### 2.2.1 用Java技术和单机来构建的网站
Servlet + JSP + JDBC
#### 2.2.2 从一个单机的交易网站说起
#### 2.2.3 单机负载告警，数据库与应用分离
#### 2.2.4 应用服务器负载告警，如何让应用服务器走向集群
引入集群
* 负载均衡
* Session问题 会话保持
  * SessionSticky
  * SessionReplication 服务器之间会话同步 缺点：同步Session网络宽带开销，每台服务器保持所有的Session
  * Session数据集中存储
  * CookieBased 通过Cookie传递Session数据。缺点：Cookie长度限制，安全性，宽带消耗，性能影响

#### 2.2.5 数据库读压力大，读写分离吧
1. 采用数据库作为读库，增加读库，分担主库的压力
   * 数据复制问题 复制时延、短期**数据不一致**。
   * 应用对数据源的选择问题 写走主库，事务中的读走主库
2. 搜索引擎其实就是一个读库。构建索引的过程就是一个数据复制的过程。
3. 加速数据读取的利器----缓存 数据缓存、页面缓存；缓存命中率、更新策略

#### 2.2.6 弥补关系型数据库的不足，引入分布式存储系统
常见的分布式存储系统有分布式文件系统、分布式key-value系统和分布式数据库。

分布式存储系统通过集群提供了一个高容量、高并发访问、数据冗余容灾的支持。
#### 2.2.7 读写分离后，数据库又遇到瓶颈
1. 专库专用，数据垂直拆分 数据库中不同的业务数据拆分到不同的数据库中。
   * 应用需要配置多个数据源
   * 跨业务的事务，表关联的查询改变实现
2. 垂直拆分后的单机遇到瓶颈，数据水平拆分
   * SQL路由问题、主键

!> 数据水平拆分与读写分离的区别是，读写分离解决的是读压力大的问题，对于数据量大或者更新量的情况并不起作用。
数据水平拆分与垂直拆分的区别是，垂直拆分是把不同的表拆分到不同的数据库中，而水平拆分是把同一个表拆分到不同的额数据库中。

#### 2.2.8 数据库问题解决后，应用面对新的挑战
1. 拆分应用
2. 走服务化的路 引入远程服务调用

#### 2.2.9 初试消息中间件
异步和解耦。

## 第3章 构建Java中间件
### 3.1 Java中间件的定义

?> 中间件起到的是桥梁的作用，是应用于应用之间的桥梁，也是应用于服务直接的桥梁。特定中间件是解决特定场景的问题的组件，它能够让软件开发人员专注于自己的应用开发。

### 3.2 构建Java中间件的基础知识
#### 3.2.1 跨平台的Java运行环境——JVM
#### 3.2.2 垃圾回收的内存堆布局
#### 3.2.3 Java并发编程的类、接口和方法
##### 线程池
线程池的方式是复用线程。每个线程都是消耗内存的。
##### sysnchronized
声明静态方法、实例方法、代码块
##### ReentrantLock
可重入的、显示锁。tryLock、公平锁。
非公平锁，整体效率高一些，是可以抢占的，直接被抢占，阻塞的等待队列的线程不会被唤醒。

ReentrantReadWriteLock
##### volatile
synchronized保证了synchronized块中变量的可见性，volatile则是保证了所修饰变量的可见性。
##### Atomics
##### wait/notify/notifyAll
在多线程中，可以把某个对象作为事件对象，通过这个对象的wait、notify和notifyAll方法来完成线程间的状态通知。
##### CountDownLatch
当多个线程都到达了预期状态或完成预期工作时触发事件，其他线程可以等待这个事件来触发自己吼下的工作。
##### CyclicBarrier
可以协同多个线程，让多个线程在这个屏障前等待，直到所有线程都到达了这个屏障时，再一起继续执行后面的动作。
##### Semaphore
##### Exchanger
用于两个线程之间进行数据交换。线程会阻塞在Exchanger的exchange方法上，直到另一个线程也到了同一个Exchanger的exchange方法，
二者进行交换，然后两个线程会继续执行自身相关的代码。
##### Future和FutureTask
调用后马上返回，然后继续向下执行，等需要用数据时再来用，或者再来等待这个数据。两种实现，一个Future，另一个回调。
##### 并发容器
并发容器强调容器的并发性，不仅追求线程安全，还要考虑并发，提升在容器并发环境下的性能。

!> 加锁互斥的方式确实能够方便完成线程安全，不过代价是降低了并发性，或者说是串行了。而并发容器的思路是尽量不用锁，比如CopyOnWrite和Concurrent开头的几个容器。CopyOnWrite的思路是在更改容器时候，把容器写一份在修改，适用于读多写少的场景。Concurrent开头的尽量保证读不加锁，并且修改时不影响读，所以会达到比使用读写锁更高的并发性能。

#### 3.2.4 动态代理
#### 3.2.5 反射
获取对象属于哪个类、获取类的信息、构建对象、动态执行方法、动态操作属性。
第三方库，Javasist、cglib、asm。
#### 3.2.6 网络通信实现选择
### 3.3 分布式系统中的Java中间件
中间件的范畴很广泛，后面章节介绍的中间件是指用来支撑网站从小到大的变化过程中解决**应用拆分、服务拆分、数据拆分和应用解耦**的问题的产品。

## 第4章 服务框架
### 4.1 网站功能持续丰富后的困就与应对
多个应用连一个库，互相不通信，冗余代码

### 4.2 服务框架的设计与实现
#### 4.2.1 应用从集中式走向分布式所遇到的问题
#### 4.2.2 透过示例看服务框架原型
#### 4.2.3 服务调用端的设计与实现
1. 确定服务框架的使用方式
2. 服务调用者和服务提供者之间的通信方式的选择 路由寻址、透明代理
3. 引入基于接口、方法、参数的路由
4. 多机房场景
5. 服务调用端的流控处理
6. 序列化与反序列化处理
7. 网络通信实现选择
8. 支持多种异步调用服务方式 Oneway、Callback、Future、可靠异步
9. 使用Future方式对远程服务调用优化

#### 4.2.4 服务提供端的设计与实现
1. 如何暴露远程服务
2. 服务端对请求处理的流程
3. 执行不同服务的线程隔离
4. 服务提供端的流控处理

#### 4.2.5 服务升级
对接口的某些方法修改了调用的参数列表

### 4.3 实战中的优化
### 4.4 为服务化护航的服务治理
我们可以将服务治理分为查看服务和管理服务，也就相当于数据的读和写。
* 服务查看
  * 服务信息、服务质量、服务容量、服务依赖、服务分布、服务统计、服务元数据、服务查询、服务报表、服务监视
* 服务管理
  * 服务上下线、服务路由、服务限流降级、服务归组、服务线程池管理、机房规则、服务授权

### 4.5 服务框架与ESB的对比
* 服务框架 点对点型；同构
* 企业服务总线ESB 总线型；异构

## 第5章 数据访问层
### 5.1 数据库从单机到分布式的挑战和应对
#### 5.1.1 从应用使用单机数据库开始
#### 5.1.2 数据库垂直/水平拆分的困难
在不靠升级硬件的情况下，能够想到的处理方案就是给现有数据库减压。减压的思路有三个
* 一是优化应用，看看是否有不必要的压力给了数据库（应用优化）
* 二是看看有没有其他办法可以降低对数据库的压力，例如引入缓存、加搜索引擎等
* 三是把数据库的数据和访问分到多态数据库上，分开支持，这也是我们的核心思路和逻辑

垂直拆分带来的影响
* 单机的ACID保证被打破
* 一些Join操作变的困难
* 靠外键约束的场景受影响

水平拆分带来的影响
* ACID被打破
* Join操作
* 外键约束
* 依赖单库的自增序列生成唯一ID会受到影响
* 针对单个逻辑意义上的表的查询要跨库

#### 5.1.3 单机变为多机后，事务如何处理
##### 了解分布式事务
1. 分布式事务规范与模型 X/Open组织提出的分布式事务规范XA

DTP模型
* ApplicationProgram 应用程序
* ResourceManager 资源管理器，可以理解为一个DBMS系统
* TransactionManager 事务管理器，负责协调和管理事务，提供给AP应用程序编程接口并管理资源管理器。

DTP几个概念
* 事务：一个事务是一个完整的工作单元，由多个独立的计算任务组成，这多个任务在逻辑上原子的。
* 全局事务：一次性操作多个资源管理器的事务就是全局事务
* 分支事务：在全局事务中，每一个资源管理器有自己独立的任务，这些任务的集合是这个资源管理器的分支任务
* 控制线程：用来表示一个工作线程，主要关联AP、TM和RM三者的线程，也就是事务上下文环境。


2. 两阶段提交 Prepare、Commit

##### 大型网站一致性的基础理论 CAP/BASE
CAP
* Consistency all nodes see the same data at the same time
  所有节点在同一时间读到同样的数据
* Availability a gurantee that every request receives a response about whether it was successful or failed
  保证无论是成功还是失败，每个请求都能欧收到一个响应
* Partition-Tolerance the system continues to operate despite arbitrary message loss or failure of part of the system
  即便系统中有部分问题或者有消息的丢失，但是系统仍能够继续运行

BASE模型
* Basically Availabe 基本可用，允许分区失败
* Soft state 软状态，接受一段时间的状态不同步
* Eventually consistenct 最终一致，保证最终数据的状态是一致的

##### 比两阶段提交更轻量一些的Paxos协议

##### 集群内数据一致性的算法实例

#### 5.1.4 多机的Sequence问题与处理
* 唯一性问题 UUID生成，保证了唯一性，但连续性不好
* 连续性问题 单机环境中，其实就是一个单点来完成这个任务，在分布式环境中，可以用一个独立的系统来完成这个工作

#### 5.1.5 应对多机的数据查询
##### 跨库Join
* 应用层把原来数据库Join操作分成多次的数据库操作
* 数据冗余，对一些常用的信息进行冗余
* 借助外部系统（例如搜索引擎）解决

##### 外键约束
不能完全依赖数据库本书来完成之前的功能

##### 跨库查询的问题及解决

遇到的麻烦具体取决于分库分表的方式。

对查询结果在应用上进行合并
1. 排序，即多个来源的数据查询出来后，在应用层进行排序的工作。
   如果数据库中查询出来已经排好顺序，那么在应用层要进行多路归并排序；如果查询出来未排序，就要进行一个全排序。
2. 函数处理，即使用max、min、sum、count等函数对多个数据来源的值进行相应的函数处理
3. 求平均值，从多个数据来源进行查询时，需要把SQL改为查询sum和count，然后多多个数据来源的sum求和，count求和后，计算平均值
4. 非排序分页，同等步长在多个数据源分页，还是同等比例
5. 排序分页，最复杂的情况，必须把**足够多的数据**返回给应用，才能得到正确的结果，复杂之处在于将足够多的数据返回应用。

### 5.2 数据库访问层的设计与实现
#### 5.2.1 如何对外提供数据访问层的功能
##### 对外提供数据访问层的方式
* 专有API 无通用性
* JDBC实现 扩展性和兼容性好，成本高
* ORM框架再包装

#### 5.2.2 按照数据层流程的顺序看数据层设计
##### SQL解析阶段的处理
##### 规则处理阶段
1. 固定哈希算法作为规则 id取模，时间维度（天、星期、月、年）
2. 一致性哈希算法带来的好处 把节点对应的哈希值变为一个范围，把这个范围定义得非常大
3. 虚拟节点对一致性哈希的改进
4. 映射表与规则自定义计算方式

##### 为什么要改写SQL 
表明可能不一样。跨库计算平均值，不是多个数据源的平均值的平均值，必须修改SQL获取到数量、总数后再进行计算。
##### 如何选择数据源
##### 执行SQL和结果处理阶段
对异常的处理和判断
##### 实战经验分享
1. 复杂的连接管理
2. 三层数据源的支持和选择

#### 5.2.3 独立部署的数据访问层实现方式
如果采用Proxy方式的话，客户端与Proxy之间的协议有两种选择：数据库协议和私有协议。
* 数据库协议 成本高，应用到Proxy的之间的连接不能复用
* 私有协议 相对简单，应用到Proxy的之间的连接可以复用

#### 5.2.4 读写分离的挑战和应对
数据复制的问题，也就是把主库的数据复制到备库中。
##### 主库从库非对称的场景
1. 数据结构相同，多从库对应一主库场景 消息系统通知复制，不优雅；基于数据库的日志进行数据复制。
2. 主/备库分库方式不同的数据复制
3. 引入数据变更平台

##### 如何做到数据平滑迁移
不停机迁移。迁移过程中又会有数据的变化。
可以考虑的方案是，在开始进行数据迁移时，记录增量的日志，在迁移结束后，再对增量的变化进行处理。在最后，可以把要被迁移的数据的写暂停，保证增量日志都处理完毕后，再切换规则，放开所有的写，完成迁移工作。

## 第6章 消息中间件
### 6.1 消息中间件的价值
#### 6.1.1 消息中间件的定义
#### 6.1.2 透过示例看消息中间件对应用的解耦
##### 通过服务调用让其他系统感知事件发生的方式
用户登录成功后的动作。每增加一个登录成功后需要被调用的系统，就需要修改登录系统进行相关的调用。登录系统**被迫依赖**非常多的系统。
##### 通过引入消息中间件解耦服务调用
分析依赖关系，登录系统不需要依赖其他系统，其他系统系统必须依赖登录系统。

服务调用会被固定格式的消息传递取代，登录系统负载向消息中间件发送消息，而其他的系统则向消息中间件来订阅这个消息，然后完成自己的工作。

### 6.2 互联网时代的消息中间件
在大型互联网中，我们采用消息中间件可以进行**应用之间的解耦**以及**操作的异步**，这是消息中间件的两个最重要的特点。
在此基础之上，我们着重思考的是消息的顺序保证、扩展性、可靠性、业务操作与消息发送一致性，以及多集群订阅者等方面的问题。

#### 6.2.1 如何解决消息发送一致性
!> 消息发送一致性是指产生消息的业务动作与消息发送的一致，就是说，
如果业务操作成功了，那么由这个操作产生的消息一定要发送出去，否则就是消息丢失了。而另一方面，若果这个业务行为没有发生或者失败，那么就不应该把消息发出去。

```ts
// 先业务操作、后发消息
void foo1() {
    // 业务操作
    // 例如写数据库，调用服务等
    // 发送消息
}
// 先发消息、后业务操作
void foo2() {
    // 发送消息
    // 业务操作
    // 例如写数据库，调用服务等
}
// 解决之道
Resutlt postMessage(Message, PostMessageCallback) {
    // 发送消息给消息中间件
    // 获取返回结果
    // 如果失败，返回失败
    
    // 进行业务操作
    // 获取业务操作结果
    
    // 发送业务操作结果给消息中间件
    // 返回处理结果
}
```

#### 6.2.2 如何解决消息中间件与使用者的强依赖问题
* 提供消息中间件系统的可靠性，但是没有办法保证百分百可靠
* 对于消息中间件系统影响业务操作进行的部分，使其可靠性与业务自身的可靠性相同
* 可以提供弱依赖的支持，能够较好地保证一致性

#### 6.2.3 消息模型对消息接收的影响
1. JMS Queue模型 一个消息只被一个应用消费一次
2. JMS Topic模型 多个应用可以独立收到**所有**到达Topic的消息
3. JMS中客户端连接的处理和带来的限制
   * JMS Queue 每个应用的每个连接收到**某一个不同的**消息
   * JMS Topic 每个应用的每个连接收到**所有的相同的**消息
   * 集群消费问题？
4. 我们需要什么样的模型
   * 消息发送方与接收方都是集群
   * 同一个消息的接收方可能有多个集群进行消息的处理
   * 不同集群对同一条消息的处理不能互相干扰

我们可以把集群和集群之间对消息的消费当做Topic模型处理，而集群内部的各个具体应用实例对消息的消费当做Queue模型来处理。
引入ClusterId，标识不同的集群，而集群内的各个应用实例的连接使用同样的ClusterId。
当服务端进行调度时，根据ClusterId进行连接的分组，在不同的ClusterId之间保证消息的独立投递，而拥有相同ClusterId的连接则**共同消费**这些消息。
这个策略分两级来处理，把Topic模型和Queue模型的特点结合起来使用。

#### 6.2.4 消息订阅者订阅消息的方式
#### 6.2.5 保证消息可靠性的做法
消息从发送端应用到接收端应用，总结有三阶段需要保证可靠，分别是：
* 消息发送者把消息发送到消息中间件 发送者和中间件直接**调用返回**结果清晰设定
* 消息中间件把消息存入消息存储
  * 基于文件、采用数据库、基于双机内存
  * 消息扩容 消息中间件扩容、消息存储扩容
* 消息中间件把消息投递给消息接收者 中间件要显示收到接收者的处理完毕的信号才能删除消息

#### 6.2.6 订阅者视角的消息重复的产生和应对
* 消息发送端应用的消息重复发送  解决：发送重试时使用同样的消息id，不要使用中间件端产生消息id
  * 消息中间件成功存储，中间件出现问题，应用端没有收到成功的返回，重试产生重复
  * 消息中间件负载高响应变慢，成功存储消息后，返回“成功”这个结果超时
* 消息到达了消息存储，消息中间件重复投递 解决：接收者的处理要支持幂等
  * 接收者处理异常，消息中间件不知道处理结果，会再次投递
  * 接收者处理成功，网络出问题
  * 接收者处理慢
  * 接收者处理成功，消息中间件出现问题，没有收到消息结果
  * 接收者处理成功，消息中间件收到结果，遇到消息存储故障，没能更新投递状态

#### 6.2.7 消息投递的其他属性支持
* 消息优先级
* 订阅者消息处理顺序和分级订阅
* 自定义属性
* 局部顺序

#### 6.2.8 保证顺序的消息队列的设计
#### 6.2.9 Push和Pull方式的对比

## 第7章 软负载中心与集中配置管理
### 7.1 初识软负载中心
### 7.2 软负载中心的结构
### 7.3 内容聚合功能的设计
### 7.4 解决服务上下线的感知
### 7.5 软负载中心的数据分发的特点和设计
#### 7.5.1 数据分发与消息订阅的区别
#### 7.5.2 提升数据分发性能需要注意的问题
### 7.6 针对服务化的特性支持
#### 7.6.1 软负载数据分组
#### 7.6.2 提供自动感知以外的上下线开关
#### 7.6.3 维护管理路由规则
### 7.7 从单机到集群
#### 7.7.1 数据统一管理方案
#### 7.7.2 数据对等管理方案
### 7.8 集中配置管理中心
#### 7.8.1 客户端实现和容灾策略
#### 7.8.2 服务端实现和容灾策略
#### 7.8.3 数据库策略

## 第8章 构建大型网站的其他要素
### 8.1 加速静态内容访问速度的CDN
CDN其实就是一种网络缓存技术，能够把一些相对稳定的资源放到距离最终用户较近的机房。
* 全局调度
* 缓存技术
* 内容分发
* 带宽优化

### 8.2 大型网站的存储支持
存储系统，关系型数据库、分布式文件系统、NoSQL、缓存
#### 8.2.1 分布式文件系统
#### 8.2.2 NoSQL
#### 8.2.3 缓存系统

### 8.3 搜索系统
* 爬虫
* 倒排索引 原来作为值的内容拆分为索引的Key，作为索引的Key转变成了值
* 查询预处理
* 相关度计算

### 8.4 数据计算支撑
* 离线计算（MapReduce）
* 在线计算（Storm）

### 8.5 发布系统
分发应用、启动校检、灰度发布
### 8.6 应用监控系统
数据监视维度、数据记录方式、数据采集方式、展现与告警
### 8.7 依赖管理系统
调用链
### 8.8 多机房问题分析
多机房主要用于容灾，以及改进不同地域的用户的访问速度。同城机房、异地机房。
### 8.9 系统容量规划
### 8.10 内部私有云
对于内部私有的构建，需要考虑如何把已经形成规模的内部工具、系统较好地**糅合**在一起。

云计算带给我们的是看起来用之不尽的资源，这背后要求我们的资源能够**动态扩展**，并且在不需要时能够**动态收缩**。
