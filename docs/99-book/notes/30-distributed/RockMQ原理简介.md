《RocketMQ原理简介》淘宝消息中间件项目组


## 1 前言
JMS规范与CORBA Notification规范

RocketMQ并不遵循任何规范，但是草了各种规范和同类产品的设计思想。

## 2 产品发展历史
- Metaq 1.x
- Metaq 2.x
- RocketMQ 3.x

## 3 专业术语
- 角色
  - Producer
  - Comsumer
  - PushComsumer 应用向Comsumer对象注册Listener接口，一旦收到消息，Comsumer对象立刻回调Listener接口方法。
  - PullConsumer 应用主动调用Comsumer的拉消息方法从broker拉消息，主动权由应用控制
  - ProducerGroup Producer集合，这类Producer通常发送一类消息，且发送逻辑一致
  - ConsumerGroup Consumer集合，这类Consumer通常消费一类消息，且发送逻辑一致
  - Brokder 消息中转角色，负责存储消息，转发消息，一般也称为Server，在JMS规范中称为Provider
- 消息类型
  - 广播消息 一条消息被多个Comsumer消息，即使这些Comsumer属于同一个ComsumerGroup，
    消息也会被ComsumerGroup中的**每个Comsumer**都消费一次。
  - 集群消息 一个ComsumerGroup中的Comsumer实例**平均分摊**消息消息。
  - 顺序消息 主要指的是局部顺序，Producer单线程顺序发送，且发送到同一个队列
  - 普通顺序消息 产生短暂的消息顺序不一致
  - 严格顺序消息 无论正常异常情况都能保证顺序，但是牺牲了分布式`Failover`特性，即 Broker 集群中只要有一台机器不可用，则整个集群都不可用，服务可用性大大降    低。只有数据库 binlog 同步强依赖严格顺序消息
  - MessageQueue 在 RocketMQ 中，所有消息队列都是持久化，长度无限的数据结构，
    所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用 Offset 来访问，offset 为 java long 类型，64 位，
    理论上在 100年内不会溢出，所以认为是长度无限，
    另外队列中只保存最近几天的数据，之前的数据会按照过期时间来删除。

## 4 消息中间件需要解决哪些问题？
### 4.1 Publish/Subscribe
### 4.2 Message Priority
由于 RocketMQ 所有消息都是持久化的，所以如果按照优先级来排序，开销会非常大，因此 RocketMQ 没有特
意支持消息优先级，但是可以通过变通的方式实现类似功能，即单独配置一个**优先级高的队列**，和一个**普通优先级的队列**，将不同优先级发送到不同队列即可。

### 4.3 Message Order
### 4.4 Message Filter
### 4.5 Message Persistence
1. 持久化到数据库
2. 持久化到KV存储
3. 文件记录形式持久化
4. 对内存数据做一个持久化镜像

### 4.6 Message Reliablity
- 硬件资源可立即恢复情况，能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）
  1. Brokder正常关闭
  2. Broker异常Crash
  3. OS Crash
  4. 集群掉电，但是能立即恢复供电情况
- 单点故障，无法恢复
  1. 机器无法开机（可能是 cpu、主板、内存等关键设备损坏）
  2. 磁盘设备损坏

RocketMQ 在这两种情况下，通过异步复制，可保证 99%的消息不丢，但是仍然会有极少量的消息可能丢失。
通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与 Money 相关的应用。

### 4.7 Low Latency Messaging
在消息不堆积情况下，消息到达 Broker 后，能立刻到达 Consumer。低延迟
### 4.8 At least Once
每个消息必须投递一次。

RocketMQ Consumer 先 pull 消息到本地，消费完成后，才向服务器返回 ack，如果没有消费一定不会 ack 消息，所以 RocketMQ 可以很好的支持此特性。
### 4.9 Exactly Only Once
- 发送消息阶段，不允许发送重复的消息
- 消费消息阶段，不允许消费重复的消息

!> RocketMQ 为了追求高性能，并不保证此特性，要求在业务上进行去重，也就是说消费消息要做到幂等性。 
此问题的本质原因是网络调用存在**不确定性**，即既不成功也不失败的第三种状态，所以才产生了消息重复性问题。

### 4.10 Broker的Buffer满了怎么办？

RocketMQ 没有内存 Buffer 概念，RocketMQ 的队列都是持久化磁盘，数据定期清除。
### 4.11 回溯消费
### 4.12 消息堆积
消息中间件的主要功能是异步解耦，还有个重要功能是挡住前端的数据洪峰，保证后端系统的稳定性，
这就要求消息中间件具有一定的消息堆积能力，消息堆积分以下两种情况：
1. 消息堆积在内存 Buffer，一旦超过内存 Buffer，可以根据一定的丢弃策略来丢弃消息
2. 消息堆积到持久化存储系统中，例如 DB，KV 存储，文件记录形式。

评估消息堆积能力主要有以下四点：
1. 消息能堆积多少条，多少字节？即消息的堆积容量。
2. 消息堆积后，发消息的吞吐量大小，是否会受堆积影响？
3. 消息堆积后，正常消费的 Consumer 是否会受影响？
4. 消息堆积后，访问堆积在磁盘的消息时，吞吐量有多大？

### 4.13 分布式事务
已知的几个分布式事务规范，如 XA，JTA 等。

分布式事务涉及到两阶段提交问题，在数据存储方面的方面必然需要 KV 存储的支持，
因为第二阶段的提交回滚需要修改消息状态，一定涉及到根据 Key 去查找 Message 的动作。 
RocketMQ 在第二阶段绕过了根据 Key 去查找Message 的问题，采用第一阶段发送 Prepared 消息时，拿到了消息的 Offset，
第二阶段通过 Offset 去访问消息，并修改状态，Offset 就是数据的地址。

### 4.14 定时消息
定时消息是指消息发到 Broker 后，不能立刻被 Consumer 消费，要到特定的时间点或者等待特定的时间后才能被消费。

RocketMQ 支持定时消息，但是不支持任意时间精度，支持特定的 level，例如定时 5s，10s，1m 等。
### 4.15 消息重试
Consumer 消费消息失败后，要提供一种重试机制，令消息再消费一次。 

## 5 RocketMQ Overview

## 6 RocketMQ存储特点
### 6.1 零拷贝原理
- mmap + write：RocketMQ 选择的方式
  - 优点：即使频繁调用，使用小块文件传输，效率也很高
  - 缺点：不能很好的利用 DMA 方式，会比 sendfile 多消耗 CPU，内存安全性控制复杂，需要避免 JVM Crash问题
- sendfile
  - 优点：可以利用 DMA 方式，消耗 CPU 较少，大块文件传输效率高，无内存安全新问题
  - 缺点：小块文件效率低于 mmap 方式，只能是 BIO 方式传输，不能使用 NIO。

### 6.2 文件系统
### 6.3 数据存储结构
- topic/queueId/message
- 消息队列服务 offset/size/tagsCode
- 消息索引服务 offset/key
- 事务状态服务 offset/state(p/c/r)
- 定时消息服务 offset/delayLevel

## 7 RocketMQ关键特性
### 7.1 单机支持1万以上持久化队列
1. 所有数据单独存储到一个 CommitLog，完全顺序写，随机读。
2. 对最终用户展现的队列实际只存储消息在 CommitLog 的位置信息，并且串行方式刷盘

### 7.2 刷盘策略
同步刷盘与异步刷盘的唯一区别是异步刷盘写完 PAGECACHE 直接返回，而同步刷盘需要等待刷盘完成才返回，
同步刷盘流程如下：
1. 写入 PAGECACHE 后，线程等待，通知刷盘线程刷盘。
2. 刷盘线程刷盘后，唤醒前端等待线程，可能是一批线程。
3. 前端等待线程向用户返回成功。

### 7.3 消息查询
按照MessageId查询消息；按照MessageKey查询消息
### 7.4 服务器消息过滤
### 7.5 长轮询Pull
### 7.6 顺序消息
### 7.7 事务消息
### 7.8 发送消息负载均衡
### 7.9 订阅消息负载均衡
### 7.10 单队列并行消息
### 7.11 发送定时消息
### 7.12 消息消费失败，定时重试
### 7.13 HA，同步双写/异步复制
异步复制的实现思路非常简单，Slave 启动一个线程，不断从Master拉取CommitLog中的数据，然后在异步build出ConsumeQueue数据结构。
整个实现过程基本同 Mysql 主从同步类似。

### 7.14 单个JVM进程也能利用机器超大内存
### 7.15 消息堆积问题解决办法
在有Slave情况下，Master一旦发现Consumer访问堆积在磁盘的数据时，会向Consumer下达一个重定向指令，令Consumer从Slave拉取数据，
这样正常的发消息与正常消费的 Consumer 都不会因为消息堆积受影响，因为系统将堆积场景与非堆积场景分割在了两个不同的节点处理。 

这里会产生另一个问题，Slave会不会写性能下降，答案是否定的。
因为 Slave 的消息写入只追求吞吐量，不追求实时性，只要整体的吞吐量高就可以，而 Slave 每次都是从 Master 拉取一批数据，如 1M，
这种批量顺序写入方式即使堆积情况，整体吞吐量影响相对较小，只是写入RT会变长。

## 8 RocketMQ通信组件
### 8.1 网络协议
1. length 大端4个字节整数，等于2、3、4长度总和
2. header length 大端4个字节整数，等于3个长度
3. header data 使用json序列化数据 
4. body data 应用自定义而进行序列化数据

```js
// header
{
    "code":0,
    "language":"JAVA",
    "version":0,
    "opaque":0,
    "flag":1,
    "remark":"hello",
    "extFiels":{
        "count":0,
        "messageTitle":"Hello"
    }
}
```

### 8.2 心跳处理
通信组件本身不处理心跳，由上层进行心跳处理。
### 8.3 连接复用
同一个网络连接，客户端多个线程可以同时发送请求，应答响应通过 header 中的 opaque 字段来标识。
### 8.4 超时连接
如果某个连接超过特定时间没有活动（无读写事件），则自动关闭此连接，并通知上层业务，清除连接对应的
注册信息。

## 9 RocketMQ服务发现（Name Server）
Name Server 是专为 RocketMQ 设计的轻量级**名称服务**，代码小于 1000 行，具有简单、可集群横向扩展、无状
态等特点。将要支持的主备自动切换功能会强依赖 Name Server。


