《Redis设计与实现》 黄建宏

* 数据结构与对象 简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表、对象
* 单机数据库的实现 RDB、AOF、事件、客户端、服务端
* 多机数据库的实现 复制、sentinel、集群
* 独立功能的实现 发布订阅、事务、Lua脚本、排序、二进制位数组、慢查询日志、监视器

## 第1章 引言

# 第一部分 数据结构与对象
* 底层实现数据结构
* Redis的对象处理机制以及数据库的实现原理

## 第2章 简单动态字符串
Simple Dynamic String，简单动态字符串 
```c++
// sds.h/sdshdr
struct sdshdr {
    // 记录buff数组中已使用字节的数量，等于SDS所保存字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    char buf[];
}
```

## 第3章 链表
### 3.3 重点回顾
* 每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，双端链表
* 每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。

## 第4章 字典
字典，又称为符号表、关联数组或映射，是一种用于保存键值对的抽象数据结构。
### 4.1 字典的实现
### 4.2 哈希算法
### 4.3 解决键冲突
使用链地址法解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个**单向链表**，被分配到
同一个索引上的多个节点可以用这个单向链表连接起来。
### 4.4 rehash
键值对逐渐增多或者减少，为了让负载因子维持一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，需要对哈希表
进行相应的扩展或者收缩。

### 4.5 渐进式rehash
### 4.6 字典API

## 第5章 跳跃表
skiplist是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目标。
有序集合键的底层实现之一。

Redis中两个地方用了跳跃表，实现有序集合键，集群节点中用作内部数据结构。

## 第6章 整数集合
intset是集合键的底层实现之一。当一个集合只包含整数值元素，并且这个集合的元素数量不多时。

## 第7章 压缩列表
ziplist是列表键合哈希键的底层实现之一。

### 7.1 压缩列表的构成
压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的**连续内存块**组成的**顺序型**数据结构。一个压缩列表可以包含任意
多个节点，每个节点可以保存一个字节数组或者一个整数值。

## 第8章 对象
Redis并没有直接使用这些数据结构，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、
集合对象和有序集合对象。

Redis使用对象来表示数据库中的键和值。当在Redis新建一个键值对时，至少会创建两个对象，
一个对象用来做键值对的键，另一个对象用来做键值对的值。
```
typeof struct redisObject {
    unsigned type:4; // 类型
    unsigned ecoding:4; // 编码
    void *ptr; // 指向底层实现数据结构的指针
}
```

* 字符串对象 字符串对象的编码可以是int、raw或者embstr
* 列表对象 列表对象的编码可以是ziplist或者linkedlist
* 哈希对象 哈希对象的编码可以是ziplist或者hashtalbe
* 集合对象 集合对象的编码可以是intset或者hashtable
* 有序集合对象 有序集合的编码可以是ziplist或者skiplist

Redis的对象系统实现了基于引用计数的内存回收机制。通过引用计数实现了对象的共享机制。

# 第二部分 单机数据库的实现
## 第9章 数据库
### 9.5 过期键删除策略
- 定时删除 timer定时，键过期时删除。大量定时器耗CPU、查找Key不易（无序链表）
- 惰性删除 使用时判断删除。对内存不友好
- 定期删除 每隔一段时间，删除过期key

### 9.6 Redis的过期键删除策略
### 9.7 AOF、RDB和复制功能对过期键的处理
- 生成RDB 过滤过期的
- 载入RDB 主服务器时，过滤过期的；从服务器时，保存所有
- AOF文件写入 过期但是没有被惰性删除或定期删除，不受影响；删除之后追加del命令
- AOF重写 过滤过期的
- 复制 从服务器的删除动作由主服务器决定

## 第10章 RDB持久化
### 10.5 
* save 服务器进程执行保存操作，会阻塞服务
* bgsave 子进程执行保存操作，不会阻塞

## 第11章 AOF持久化
### 11.4
* aof 
* AOF重写 产生一个新的AOF文件，体积更小

## 第12章 事件
Redis服务器是一个事件驱动的程序，服务器需要处理一下两类事件
- 文件事件
- 时间事件

### 12.1 文件事件
Redis基于Reactor模式开发了自己的网络事件处理器
- 文件事件处理器使用了IO多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器
- 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作，
与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联的事件处理器来处理这些事件。

#### 12.1.1 文件事件处理器的构成
套接字、IO多路复用程序、文件事件分派器、事件处理器

#### 12.1.2 IO多路复用程序的实现
Redis的IO多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些IO多路复用函数库来实现的，
每个IO多路复用函数在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kequeue.c。

- IO多路复用
  - select
  - epoll
  - evport
  - kqueue

#### 12.1.3 事件的类型
AE_READABLE AE_WRITEABLE
#### 12.1.4 API

### 12.2 时间事件
### 12.3 事件的调度与执行
### 12.4 重点回顾
* Redis服务器是一个事件驱动程序，时间事件、文件事件
* 文件事件处理器是基于Reactor模式实现的网络通信程序
  - 对套接字操作的抽象，每次套接字变为可应答（acceptable）、可写、可读时，相应的事件就会产生 
  - AE_READBlE读事件、AE_WRITABLE写事件
* 时间事件可分为定时事件（指定时间）和周期性事件（每隔一段时间）。

## 第13章 客户端
## 第14章 服务器
### 14.4
* 一个命令请求
  1. 客户端将命令请求发送到服务器
  2. 服务器读取命令请求，并分析出命令参数
  3. 命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复
  4. 服务器将命令回复返回给客户端 
* serverCron函数默认每隔100毫秒执行一次，它的主要工作包括更新服务器状态、处理服务器接受的sigterm信号，
  管理客户端资源和数据库连接，检查并执行持久化操作
* 服务器启动到处理客户端命令
  1. 初始化服务器状态
  2. 载入服务器配置
  3. 初始化服务器数据结构
  4. 还原数据库状态
  5. 执行事件循环 

# 第三部分 多机数据库的实现
## 第15章 复制
在Redis中，用户可以通过执行slaveof命令或者设置slaveof选项，让一个服务器去复制另一个服务器，
我们称呼被复制的服务器为主服务器，而对主服务器进行复制的服务器则被称为从服务器。
### 15.1 旧版复制功能的实现
- 同步
- 命令传播

### 15.3 新版复制功能的实现
为了解决旧版复制功能在处理**断线重复制**情况时的低效问题，Redis从2.8版本开始使用`psync`命名代替`sync`命令来执行复制时的同步操作。
### 15.4 部分重同步的实现
1. 复制偏移量
2. 复制积压缓冲区 主服务器维护的一个固定长度的先进先出队列，默认大小1MB。`repl-backlog-size`
3. 服务器运行ID run ID

### 15.5 PSYNC命令的实现
### 15.6 复制的实现
```sh
# slaveof <master_ip> <master_port>  
slaveof 127.0.0.1 6379
# masterauth
```
1. 设置主服务器的地址和端口
2. 建立套接字连接
3. 发送ping命令 从服务器成为主服务器的客户端之后，从服务器向主服务器发送ping命令
4. 身份验证
5. 发送端口信息
6. 同步
7. 命令传播 主服务器执行的写命令发送给从服务器

## 第16章 Sentinel
Sentinel（哨兵）是Redis的**高可用性**解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，
以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，
自动将下线的主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。

### 16.1 启动并初始化Sentinel
### 16.2 获取主服务其信息
### 16.3 获取从服务器信息
### 16.4 想主服务其和从服务器发送信息
### 16.5 接收来自主服务器和从服务器的频道信息
### 16.6 检测主观下线状态
在默认情况下，Sentinel会以每秒一次的频率想所有与它创建了命令连接的实例发送ping命令，并通过实例返回的ping命令回复来判断实例是否在线。

`down-after-milliseconds`毫秒内无回复，表示这个实例进入主观下线状态`sri_s_down`。
### 16.7 检测客观下线状态
为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel进行询问，
当Sentinel从其他Sentinel那里接收到足够数量的已下线判断后，Sentinel就会将从服务器判定为客观下线，并对主服务器执行**故障转移**。

- 发送询问命令 `is-master-down-by-addr <ip> <port> <current_epoch> <runid>`
- 回复询问命令
- 统计回复，其他同意主服务器下线的数量达到配置指定的客观下线的数量

```sh
# sentinel启动时载入配置
sentinel monitor master 127.0.0.1 6379 2 # 包括当前Sentinel在内，只要总共有两个Sentinel认为主服务器进入客观下线的配置数量
```
### 16.8 选举领头Sentinel
当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个零头sentinel，
并由领头sentinel对下线主服务器执行故障转移。

### 16.9 故障转移
- 选出新的主服务器
- 修改从服务器的复制目标
- 将旧的主服务器变为从服务器

## 第17章 集群
Redis集群，提供分布式数据库方案，集群通过**切片**来进行数据库共享，并提供复制和故障转移功能。

### 17.1 节点
刚开始时，每个节点都是相互独立的。

```sh
# 启动节点配置 cluster-enabled
cluster meet <ip> <port> # 向某个节点发送命令，添加到自己的集群中
```
节点A发送cluster meet命令，将节点B添加到自己的集群内，之后节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，
让其他节点也与节点B进行握手，最终，经过一段时间后，节点B会被集群中的所有节点认识。
### 17.2 槽指派
Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽中的一个。

当集群中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中任何一个槽没有得到处理，那么集群处于下线状态（fail）。
```sh
# 槽指派
cluster addslots <slot> [slot ...]
```
slots属性是一个二进制位数组，这个数组的长度为`16384/8=2048`个字节，共包含16384个二级制位。0为起始索引，16383为终止索引。
### 17.3 在集群中执行命令
- 如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令
- 如果键所在的槽并没有指派个当前节点，那么节点会向客户端返回一个moved错误，指引客户端转向至正确的节点

1. 计算键属于哪个槽
2. 判断槽是否由当前节点负责处理
3. MOVE错误

节点和单机服务器在数据库方面的一个区别是，节点只能使用0号数据库，而单机Redis服务器则没有这一限制。
### 17.4 重新分片
### 17.5 ASK错误
在进行重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现这样一种情况：
属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面。
- 源节点找到指定键，直接执行客户端命令
- 源节点找不到，返回ASK错误，指引客户端转向正在导入槽的目标节点。

### 17.6 复制与故障转移
Redis集群中的节点分为主节点和从节点，其中主节点用于处理槽，而从节点则用于复制某个主节点，
并在被复制的主节点下线时，代替下线主节点继续处理命令请求。

#### 17.6.1 设置从节点 
`cluster replicate <node_id>`
#### 17.6.2 故障检测
如果在一个集群里面，**半数以上**复制处理槽的主节点都将某个主节点x报告为疑似下线（probable fail），那么这个主节点x将被标记为已下线（fail），
将主节点x标记为已下线的节点会向集群广播一条关于主节点x的fail消息，所有收到这条fail消息的节点都会立即将主节点x标记为已下线。
#### 17.6.3 故障转移
当一个从节点发现自己正在复制的主节点进入了已下线状态时，**从节点**将开始对下线主节点进行故障转移。
- 下线主节点的从节点里边，会有一个从节点被选中
- 被选中的从节点会执行slaveof no one命令，成为新的主节点
- 槽指派给自己
- 新的主节点向集群中广播pong消息，集群中其他的节点立即知道
- 新的主节点开始接收和处理槽相关命令

#### 17.6.4 选举新的主节点
- 配置纪元是一个自增计数器
- 对于每个纪元，集群里每个主节点会有一次投票的机会，第一个向主节点要求投票的从节点将获得主节点的投票
- 从节点发现自己的主节点进入下线状态，会广播消息，要求投票
- 其他未投过票的主节点可以投票，仅能投一次
- 从节点收集投票结果，半数以上，从节点会当选为新的主节点

### 17.7 消息
集群中各节点通过发送和接收消息来进行通信。
- meet消息
- ping消息 集群里的每个节点默认每个一秒就会从已知及诶单里随机选出五个节点
- pong消息 作为meet或ping的响应，或者广播pong消息让其他节点立即刷新关于这个节点的认识
- fail消息 广播某个主节点下线消息
- publish消息

# 第四部分 独立功能的实现
## 第18章 发布与订阅
Redis的发布与订阅功能由publish、subscribe、psubscribe等命令组成。
```sh
subscribe "news.it" # 普通订阅 
publish "news.it" "hello" # 发布
unsubscribe "news.it"
psubscribe "news.[ie]t" # 模式订阅
punsubscribe "news.it"

pubsub channels [pattern]
pubsub numsub
```
## 第19章 事务
Redis通过multi、exec、watch等命令来实现事务功能。
事务提供了将多个命令请求打包，然后一次性、按顺序执行多个命令的机制，并且在事务执行期间，
服务器不会中断事务而改去执行其他客户端的命令请求。

```sh
multi # 开启事务
set name abc
set author demo
get name
exec # 提交事务
```

watch命令是一种乐观锁，检查被监视的键是否至少有一个已经被修改过了。
```sh
watch name # watch期间被其他客户端修改，则不执行
multi
set name hello
exec
```

### 19.3 事务的ACID性质
Reids的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务的回滚机制。
- 原子性 不支持回滚
- 一致性 
- 隔离性 Redis单线程串行执行
- 耐久性 依赖于持久化策略

## 第20章 Lua脚本
```sh
eval "return 'hello world'" 0
```
## 第21章 排序
Redis的sort命令可以对列表键、集合键或者有序集合键的值进行排序。
```sh
sort <key>
```
## 第22章 二进制位数组
```sh
setbit
getbit
bitcount
bitop # bitop and/or/xor
```
Redis使用字符串对象来表示位数组，因为字符串对象使用的SDS数据结构是二进制安全的。

## 第23章 慢查询日志
```sh
# 配置慢查询
showlog-log-slower-than 100 # 指定执行时间超过多少微妙的命令请求会被记录到日志上
slowlog-max-len # 指定服务器最多保存多少条慢查询日志
# 查询慢查询
slowlog get
```
## 第24章 监视器
通过执行monitor命令，客户端可以将自己变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息。
```sh
monitor
```
每当一个客户端向服务器发送一条命令请求时，服务器除了会处理这条命令请求之外，还会将关于这条命令请求的信息发送给所有监视器。