

@Scheduled(cron = "0/10 * * * * ?")

缺点：
- 不支持集群：集群情况下容易造成任务重复问题
- 不支持失败重试：失败即结束，不支持重试
- 不支持动态调整：修改任务参数时需要修改代码，并且要重启服务
- 无报警机制：任务失败后没有提醒功能
- 无统一管理：没有办法手动关闭或开启任务


### xxl-job
3、调度中心HA（中心式）：调度采用中心式设计，“调度中心”自研调度组件并支持集群部署，可保证调度中心HA；
4、执行器HA（分布式）：任务分布式执行，任务"执行器"支持集群部署，可保证任务执行HA；
5、注册中心: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。同时，也支持手动录入执行器地址；
6、弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务；
7、触发策略：提供丰富的任务触发策略，包括：Cron触发、固定间隔触发、固定延时触发、API（事件）触发、人工触发、父子任务触发；


### xxl-job
https://blog.csdn.net/qq_35958391/article/details/124554693

- 调度中心
  - 调度器 timewheel
  - Rolling日志
  - 回调服务
  - 注册服务
- 执行器
  - 执行器服务
  - 日志服务
  - 回调线程
  - 注册线程

#### 执行器注册

#### 调度中心和任务执行
1. JobRegistryMonitorHelper 不停的更新注册表，把超时的执行器剔除（每隔30s执行一次）
2. 创建线程池
   1. 调度器线程ScheduleThread：计算预读取的任务数（默认6000），然后while 循环不停的获取到期的任务
   2. 时间轮线程池
3. 获取任务锁：第一步获取数据库排它锁，如果没有成功说明其他的调度中心在加载任务
4. 查询任务：获取锁后， 查询任务
5. 调度任务
6. 任务触发，选择执行器：按照配置的路由策略，不通路由策略获取方式也不一样
7. 远程执行：拿到执行器之后，runExecutor 触发远程的执行器
8. 执行器处理远程调用，回调

#### 时间轮
一批任务都是不同的时间执行，执行时间精确到秒，如何实现对所有的任务调度这个就是时间轮。

#### 任务超时

#### 失败重试
如果任务执行失败，会更新在xxl_job_log日志表里。调度中心有个后台线程monitorThread。第一步就是查日志表里结果不是200的任务，为了防止集群下同时处理一个失败任务，用了数据库的乐观锁（版本号），如果失败重试次数>0，代表重试，就要重新触发。

调度器启动：
JobFailMonitorHelper.getInstance().start();

#### 故障转移

#### 任务分片



