
消息中间件主要是实现分布式系统中**解耦、异步消息、流量销锋、日志处理**等场景。

跨平台（硬件平台与操作系统）、跨系统、跨语言。

## JMS规范
基本概念
* 发送者（ Sender）
* 接收者（ Receiver）
* 点对点（ Point-to-Point(P2P) ）
* 发布订阅（ Publish/Subscribe(Pub/Sub) ）
* 消息队列（Queue）  一个容纳那些被发送的等待阅读的消息的区域。与队列名字所暗示的意思不同，消息的接受顺序并不一定要与消息的发送顺序相同。
  一旦一个消息被阅读，该消息将被从队列中移走。
* 主题（Topic）
* 发布者（Publisher）
* 订阅者（Subscriber）

对象模型
* ConnectionFactory  创建Connection对象的工厂，针对两种不同的jms消息模型，分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。
* Destination 消息生产者的消息发送目标（Queue、Topic）或者说消息消费者的消息来源（队列或主题）。
* Connection QueueConnection和TopicConnection
* Session QueueSession和TopicSession
* 消息的生产者 QueueSender和TopicPublisher
* 消息消费者 QueueReceiver和TopicSubscriber
* MessageListener 如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法

消息消费
* 同步 订阅者或接收者调用receive方法来接收消息，receive方法在能够接收到消息之前（或超时之前）将一直阻塞
* 异步 订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。

## 常见MQ
* ActiveMQ
* RabbitMQ 吞吐量万级，MQ功能完善；后台管理界面非常好；erlang语言
* Kafka 大数据系统的实时数据计算、日志采集
* [RocketMQ](https://blog.csdn.net/zhangll_2008/article/details/78657177)  丢失、堆积、复杂订阅关系、消息存储、容灾、扩展

| 特性                  | ActiveMQ   | RabbitMQ | RocketMQ                 | Kafka                |
| :-------------------- | :--------- | :------- | :----------------------- | :------------------- |
| 单机吞吐量            | 万级       | 万级     | 十万级                   | 十万级               |
| topic数量对吞吐量影响 |            |          | 可达几百、几千，小幅下降 | 几十、几百，大幅下降 |
| 时效性                | 高         | 高       | 非常高                   | 非常高               |
| 消息可靠性            | 低概率丢失 |          | 参数优化，0丢失          | 参数优化，0丢失      |
| 核心特点              | 功能完备   | erlang   | 分布式、扩展性           | 功能简单             |
| 优劣势                | 成熟       | 性能好   | 接口简单                 | 高吞吐量             |


### rabbitmq
交换器
1. direct 路由键匹配-一个消息到一个队列
2. fanout 将收到的消息广播到绑定的队列上-一个消息到多个队列
3. topic 不同源头的消息能够到达同一个队列-多个消息到一个队列
4. header

高可用，提供了集群、HA的机制，不是分布式的。
- 单机模式
- 普通集群模式 多态机器上启动多个rabbitmq实例，每个机器启动一个。
  - 缺点 大量数据传输，带宽压力和消耗严重；可用性几乎无保障，如果queue节点宕机会丢失
- 镜像集群模式 消息会在集群中复制，每个节点都放queue的完整数据。高可用模式。
  - 缺点 带宽压力、消耗；消息堆积；管理后台可以配置集群策略

可靠性、丢失问题
* 生产者 confirm机制
* rabbitmq 持久化到磁盘
* 消费者 关闭autoAck

```ts
// 把channel设置成comfirm的模式
// 发送一个消息，发送完消息之后不用管
// rabbitmq如果接收到了这条消息的话，就会回调生产者本地的一个接口，通知这条消息已经收到
// rabbitmq如果在接收消息时报错，就会回调生产者本地接口，消息接收失败，可以重发
```

顺序问题
- 单独的队列queue，单个消费者单线程处理

### kafka
高吞吐量的分布式发布订阅消息系统，可扩展性，持久性、可靠性，容错性，高并发。

分布式的，一个topic的数据，是分散放在多个机器上的，每个机器就放一部分数据。

使用场景
* 日志收集：收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。
* 消息系统：解耦和生产者和消费者、缓存消息等。
* 用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。
* 运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。
* 流式处理：比如spark streaming和storm
* 事件源

名词解释
* producer
* consumer 消费者可以订阅一个或多个主题(topic),并从Broker拉数据,从而消费这些已发布的消息。
* topic 消息以topic为类别记录，Kafka将消息种子(Feed)分门别类，每一类的消息称之为一个主题(Topic)。Topic分区。
* broker 以集群的方式运行,可以由一个或多个服务组成，每个服务叫做一个broker

高可用
* 0.8之前没有高可用架构。0.8之后，提供HA机制，就是replica副本机制。
* 每个partition的数据都会同步到其他机器上，形成自己的多个replica副本。
* 然后所有的replica会选举一个leader出来，那么生产和消费都跟这个leader打交道，其他replica就是follower。
* 写的时候，leader会负责把数据同步到所有的follower上，读的时候直接读leader上数据即可。

kafka会为partition选出一个leader，之后所有该partition的请求，实际操作的都是leader，然后再同步到其他的follower。

消费者定时上报offset，若消费了offset但是没有上报，重启了，可能会重复消费。（确认应答机制）

可靠性、丢失问题
- 生产者 
- kafka 集群、确认、重试
- 消费端
  - 唯一可能导致消息丢失的情况，消费者自动提交了offset，kafka以为已经消费完了，其实消费者正在处理或者宕机
  - 方案：关闭自动提交offset，手动提交offset，可能会导致重复消息，需要消费端保证幂等

```sh
# topic设置
replication.factor大于1 # 要求每个partition必须有至少2个副本
# kafa服务端设置
min.insync.replicats大于1 # 要求一个leader至少感应一个follower还跟自己保持联系
# producer端设置
acks=all # 要求每条数据必须写入所有的replica之后，才能认为写成功
retries=MAX(很大) # 要求一旦写入失败，就无限重试，阻塞到这里
```

消息顺序问题
- 写入一个partition的是有顺序的，生产者指定某个key（如订单id），同样的key会发送到一个partition（hash分发）。
- kafka保证一个消费者消费一个partition（写有序、读有序）
- 消费者若并发多个线程消费，可能会乱序。可以引入多个内存队列，按照key进行hash分发，每个thread处理一个内存队列。

### rocketmq
[分布式消息中间件-Rocketmq](https://blog.csdn.net/zhangll_2008/article/details/78657177) 
* 能够保证严格的消息顺序（需要集群的支持）
* 提供丰富的消息拉取模式（可以任意定义你的拉取方式，exmaple中也提供了一个很好的例子）
* 高效的订阅者水平扩展能力（通过一个consumerGroup的方式做到consumer的方便扩容）
* 实时的消息订阅机制（消息的实时推送，类似于上面咱们的异步消费的方式）
* 亿级消息堆积能力（轻松完成系统销锋）

专有术语
* NameServer 注册中心
* Push Consumer Consumer 的一种，应用通常通过 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调 Listener 接口方法，类似于activemq的方式
* Pull Consume Consumer 的一种，应用通常主动调用 Consumer 的拉消息方法从 Broker 拉消息，主动权由应用控制
* Producer Group
* Consumer Group
* Broker 消息中转的角色，负责存储消息（实际的存储是调用的store组件完成的），转发消息，一般也成为server，通jms中的provider
* Message Filter 可以实现高级的自定义的消息过滤，java编写
* Master/Slave 集群的主从关系，broker的name相同，brokerid=0的为主，大于0的为从
      
## 新的问题
* 引入MQ，系统的可用性降低。MQ宕机
* 导致系统考虑的问题变多，系统复杂性变高。重复、顺序、丢失、积压等
* 一致性问题：A系统成功，发消息到BCD，BC成功，D失败

### 可用
消息队列如何保证高可用性

partition集群，zk主从选举机制Leader-Follower

### 可靠
[消息可靠、丢失问题](/99-book/notes/40-architecture/大型网站系统与Java中间件实践.md?id=_625-%e4%bf%9d%e8%af%81%e6%b6%88%e6%81%af%e5%8f%af%e9%9d%a0%e6%80%a7%e7%9a%84%e5%81%9a%e6%b3%95)

消息从发送端应用到接收端应用，总结有三阶段需要保证可靠，分别是：
* 消息发送者把消息发送到消息中间件 发送者和中间件直接**调用返回**结果清晰设定
* 消息中间件把消息存入消息存储
  * 基于文件、采用数据库、基于双机内存
  * 消息扩容 消息中间件扩容、消息存储扩容
* 消息中间件把消息投递给消息接收者 中间件要显示收到接收者的处理完毕的信号才能删除消息

### 事务
消息发送一致性、事务问题

`大事务 = 小事务 + 异步`

RocketMQ实现发送事务消息
1. 第一阶段发送Prepared消息时，会拿到消息的地址
2. 第二阶段执行本地事务
3. 第三阶段通过第一阶段拿到的地址去访问消息，并修改消息的状态。

如果确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事物消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认

```ts
Resutlt postMessage(Message, PostMessageCallback) {
    // 发送消息给消息中间件
    // 获取返回结果
    // 如果失败，返回失败
    
    // 进行业务操作
    // 获取业务操作结果
    
    // 发送业务操作结果给消息中间件
    // 返回处理结果
}
```

消息的重发补偿解决思路
* 可靠消息服务定时查询状态为已发送并超时的消息
* 可靠消息将消息重新投递到 MQ 组件中
* 下游应用监听消息，在满足幂等性的条件下，重新执行业务。
* 下游应用通知可靠消息服务该消息已经成功消费。

通过消息状态确认和消息重发两个功能，可以确保上游应用、可靠消息服务和下游应用数据的最终一致性。

### 重复
消息重复与幂等

### 幂等
[幂等性，RocketMQ解决消息顺序和重复，Mysql与Java中的乐观锁悲观锁](https://blog.csdn.net/yzhou86/article/details/79156458)

MQ-client生成inner-msg-id，保证上半场幂等。这个ID全局唯一，业务无关，由MQ保证。  
业务发送方带入`biz-id`，业务接收方去重保证幂等。这个ID对单业务唯一，业务相关，对MQ透明。

在电商，银行，互联网金融等对数据准确性要求很高的领域中，这一特性具有十分重要的地位
1. MVCC多版本并发控制，乐观锁的一种实现，在数据更新时需要去比较持有数据的版本号，版本号不一致的操作无法成功。
2. 去重表 利用数据库表单的特性来实现幂等，常用的一个思路是在表上构建唯一性索引，保证某一类数据一旦执行完毕，后续同样的请求再也无法成功写入。
3. TOKEN机制 为每一次操作生成一个唯一性的凭证，也就是token。一个token在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果。

以电商平台为例子，电商平台上的订单id就是最适合的token。当用户下单时，会经历多个环节，比如生成订单，减库存，减优惠券等等。

RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。

### 顺序
消息顺序、有序性  
如何才能在MQ集群保证消息的顺序？一种简单的方式就是将M1、M2发送到同一个Server上。   
网络延迟问题，将M1和M2发往同一个消费者，且发送M1后，需要消费端响应成功后才能发送M2。  
保证生产者 - MQServer - 消费者是一对一对一的关系

PS：串行化

### 堆积
* 增大批次，瓶颈在消费吞吐量的时候，增加批次也可以改善性能  
* 增加线程数，如果一些消费者组中的消费者线程还是有 1 个消费者线程消费多个分区的情况，建议增加消费者线程。
尽量 1 个消费者线程对应 1 个分区，从而发挥现有分区数下的最大并行度。


<!-- 

解决1 consumer问题，没能消费
修复consumer问题，增加consumer，扩容消息

解决2  假设用rabbitmq，设置了过期时间TTL，queue太多超过一定时间被清理掉。
批量重新导入，从源头找出数据重新发消息，补偿

解决3 mq机器内存、硬盘耗尽
增加consumer，直接丢弃消息，之后再补偿

-->

### 如何选型

### 如何设计