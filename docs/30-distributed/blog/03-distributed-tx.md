
## 分布式事务解决方案
* [二阶段提交](https://github.com/yu199195/Raincat)
* [tcc分布式事务解决方案](https://github.com/yu199195/hmily)
* [基于消息队列最终一致性](https://github.com/yu199195/myth)
* [源码分析系列博客地址](https://yu199195.github.io/)
* [蚂蚁金福-分布式事务dtx](https://tech.antfin.com/docs/2/56495)
* [再有人问你分布式事务，把这篇扔给他](https://www.cnblogs.com/bigben0123/p/9453830.html)
* [深入理解分布式事务](http://www.codeceo.com/article/distributed-transaction.html)

### 理论基础
- JDBC、JTA
- ACID
- CAP
- BASE

### 产生原因
* services  多服务节点（服务拆分，每个服务一个库）
* resources 多数据库节点（同一服务分库），跨数据源

### 解决
解决思想
* 将业务中的事务**分解**成一个个在独立分库上执行的子事务。
* 用**异步重试**的方式执行这些子事务，由框架或应用保证重试的 “幂等”。
* 如果需要回滚，以同样方式执行另一组子事务组成的**补偿**操作，恢复事务前的业务状态。

#### DB层解决（刚性事务，严格ACID） 
合并微服务；基于XA的2PC

#### 分布式事务组件 + 业务层配合（柔性事务）
##### TCC（应用层的 2PC ）
两阶段提交的一个变种，解决了XA的一些缺点
1. 解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群
2. 同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小
3. 数据一致性，有了补偿机制之后，由业务活动管理器控制一致性

Try-Confirm-Cancel:
Try阶段：尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）
Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备**幂等设计**，Confirm失败后需要进行**重试**。
Cancel阶段：取消执行，释放Try阶段预留的业务资源 Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。

##### 本地事务表（本地消息表）
ebay
将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。 

blog-job-retry
1. 写本地消息日志，数据库ACID保证一致性
2. 定时任务轮询（扫表），发送消息（服务接口调用），更新状态
3. 异常重试，保证幂等

##### MQ事务
在RocketMQ中实现了分布式事务，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部
1. send start mq
2. execute local tx
3. send comfirm mq
4. mqserver do send to recevier until success

##### Saga事务
将长事务拆分为多个**本地短事务**，由Saga**事务协调器**协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用**补偿**操作

#### 业务层要求
可查询
超时重试
幂等
可补偿

## 蚂蚁金服 DTX 分布式事务中间件
角色
* 发起方 有且只能有一个发起方
* 参与者 分支事务
* 事务管理器 独立服务、协调；创建主事务记录、分支事务记录，根据事务状态，调用参与者提交或回滚方法

应用场景
* 支付与专制、账务
* 金融与理财
* 保险与监管报送

术语
* 事务
* 分布式事务 事务发起者、资源及资源管理器、事务协调者位于不同的分布式系统不同的节点
* 分支事务
* 发起方
* 参与者
* 事务管理器
* 主事务记录 Activity 记录，是整个分布式事务的主体。事务号、事务状态。
* 分支事务记录 Action 记录