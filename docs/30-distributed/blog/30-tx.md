https://blog.csdn.net/a745233700/article/details/122402303

### XA/2PC/3PC

### TCC
TCC（Try Confirm Cancel）是应用层的两阶段提交，所以对代码的侵入性强，其核心思想是：针对每个操作，都要实现对应的确认和补偿操作，也就是业务逻辑的每个分支都需要实现 try、confirm、cancel 三个操作

- 空回滚
空回滚出现的原因是 Try 超时或者丢包，导致 TCC 分布式事务二阶段的 回滚，触发 Cancel 操作，此时事务参与者未收到Try，但是却收到了Cancel 请求

- 悬挂
悬挂指的是二阶段的 Cancel 比 一阶段的Try 操作先执行，出现该问题的原因是 Try 由于网络拥堵而超时，导致事务管理器生成回滚，触发 Cancel 接口，
但之后拥堵在网络的 Try 操作又被资源管理器收到了，但是 Cancel 比 Try 先到。
但按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，所以此时应该拒绝执行空回滚之后到来的 Try 操作，否则会产生数据不一致

- 幂等控制：
  由于网络原因或者重试操作都有可能导致 Try - Confirm - Cancel 3个操作的重复执行，
  所以使用 TCC 时需要注意这三个操作的幂等控制，通常我们可以使用事务 xid 或业务主键判重来控制。

### Saga
Saga 事务核心思想是将长事务拆分为多个本地短事务并依次正常提交，如果所有短事务均执行成功，那么分布式事务提交；
如果出现某个参与者执行本地事务失败，则由 Saga 事务协调器协调根据相反顺序调用补偿操作，回滚已提交的参与者，使分布式事务回到最初始的状态。

### 本地消息表 -> 事务消息 -> 尽最大努力通知

#### 本地消息表

#### 事务消息
基于MQ的分布式事务方案本质上是对本地消息表的封装，整体流程与本地消息表一致，唯一不同的就是将本地消息表存在了MQ内部，而不是业务数据库中
- 优点
  - 消息数据独立存储 ，降低业务系统与消息系统之间的耦合
  - 吞吐量大于使用本地消息表方案
- 缺点
  - 一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息) 
  - 业务处理服务需要实现消息状态回查接口

#### 尽最大努力通知
最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。
它在事务主动方增加了消息校对的接口，如果事务被动方没有接收到主动方发送的消息，此时可以调用事务主动方提供的消息校对的接口主动获取
所以最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口。

### 七种方案
https://blog.csdn.net/a745233700/article/details/122402303
- 2PC/3PC：
  - 依赖于数据库，能够很好的提供强一致性和强事务性，但延迟比较高，
  - 比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。
- TCC：
  - 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，
  - 比如互联网金融企业最核心的三个服务：交易、支付、账务。
- 本地消息表/MQ 事务/尽最大努力通知：
  - 适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，
  - 事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。
- Saga 事务：
  - 由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。
  - Saga 由于缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。
  - 所以，Saga 事务较适用于补偿动作容易处理的场景