### 创建型

工抽单建原

#### 0. 简单工厂方法

简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。

简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于23种GOF设计模式之一。
简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。

客户端依赖产品类型。

- 面向对象
  - [ ] 继承 父类工厂接口或抽象类、子类具体实现
  - [ ] 多态
  - [ ] 组合
- 设计原则
  - [x] 单一职责
  - [ ] 开闭原则
  - [ ] 里氏替换
  - [ ] 接口隔离
  - [ ] 依赖倒置
  - [ ] 迪米特原则

#### 1. Factory Method（工厂方法）

意图：
> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。

适用性：
当一个类不知道它所必须创建的对象的类的时候。
当一个类希望由它的子类来指定它所创建的对象的时候。
当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。

客户端不依赖与产品类实例如何被创建。
增加了系统的抽象性和理解的难度。

- 面向对象
  - [x] 继承 父类工厂接口或抽象类、子类具体实现
  - [x] 多态
  - [ ] 组合
- 设计原则
  - [ ] 单一职责
  - [x] 开闭原则
  - [ ] 里氏替换
  - [ ] 接口隔离
  - [ ] 依赖倒置
  - [ ] 迪米特原则

回顾工厂方法模式：针对不同的产品提供不同的工厂。这样当有多个产品时就需要多个工厂。
所以希望能一个工厂提供多种产品对象而不是单一生产产品，这就引出了抽象工厂模式。


#### 2. Abstract Factory（抽象工厂）

意图：
> 提供一个创建**一系列**相关或相互依赖对象的接口，而无需指定它们具体的类。 

适用性：
一个系统要独立于它的产品的创建、组合和表示时。
一个系统要由多个产品系列（产品族）中的一个来配置时。
当你要强调一系列相关的产品对象的设计以便进行联合使用时。
当你提供一个产品类库，而只想显示它们的接口而不是实现时。

产品套餐、组合（电信套餐、肯德基套餐）
具体产品在应用层代码隔离
抽象工厂横向扩张增加产品类型需要修改工厂类，但是纵向扩张容易。

- 面向对象
  - [x] 继承 父类工厂接口或抽象类、子类具体实现
  - [x] 多态
  - [ ] 组合
- 设计原则
  - [ ] 单一职责
  - [ ] 开闭原则 横向增加类型困难、纵向扩展容易
  - [ ] 里氏替换
  - [ ] 接口隔离
  - [ ] 依赖倒置
  - [ ] 迪米特原则

#### 3. Singleton（单例）

意图：
> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

适用性：
当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。
当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。

要点
* 构造函数私有
* 保证线程安全
* 延迟加载
* 防止序列化和反序列化破坏单例
* 防御反射攻击单例

- 面向对象
  - [ ] 继承 父类工厂接口或抽象类、子类具体实现
  - [ ] 多态
  - [ ] 组合
- 设计原则
  - [x] 单一职责
  - [ ] 开闭原则 不符合
  - [ ] 里氏替换
  - [ ] 接口隔离
  - [ ] 依赖倒置
  - [ ] 迪米特原则

创建方式
1. 饿汉式 浪费内存空间
2. 懒汉式 第一次使用时创建 synchronized + 双重检查 + volatile
3. 静态内部类 利用内部类的特性，使用时才赋值（懒汉式），利用JVM，避免线程安全问题
4. 注册式  《Effective Java》推荐使用枚举式单例（饿汉式）; spring容器式
5. ThreadLocal单例 保证线程内部的全局唯一，且天生线程安全

单例的破坏，反射创建
序列化破坏 private readResolve(){} java.io.ObjectInputStream.readObject  

优点

缺点
没有借口，扩展困难。
如果要扩展单例对象，只有修改代码，没有其他途径

ServletContext
ServletConfig
ApplicationContext
DBPool

```java
public enum SingletonEnum {
    
}
```

#### 4. Builder（建造者）

意图：
> 将一个复杂对象的**构建**与它的**表示**分离，使得同样的构建过程可以创建不同的表示。

适用性：
当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
当构造过程必须允许被构造的对象有不同的表示时。

- 面向对象
  - [ ] 继承 父类工厂接口或抽象类、子类具体实现
  - [ ] 多态
  - [ ] 组合
- 设计原则
  - [ ] 单一职责
  - [ ] 开闭原则 横向增加类型困难、纵向扩展容易
  - [ ] 里氏替换
  - [ ] 接口隔离
  - [ ] 依赖倒置
  - [ ] 迪米特原则

#### 5. Prototype（原型）

意图：
> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

适用性：
当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者
为了避免创建一个与产品类层次平行的工厂类层次时；或者
当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

Object.clone

- 面向对象
  - [ ] 继承 父类工厂接口或抽象类、子类具体实现
  - [ ] 多态
  - [ ] 组合
- 设计原则
  - [ ] 单一职责
  - [ ] 开闭原则 横向增加类型困难、纵向扩展容易
  - [ ] 里氏替换
  - [ ] 接口隔离
  - [ ] 依赖倒置
  - [ ] 迪米特原则



