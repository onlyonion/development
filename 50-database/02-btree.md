

## 二叉查找树
左子树的键值小于根的键值，右子树的键值大于根的键值

## 平衡二叉树（AVL Tree）
平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1

## 平衡多路查找树（B-Tree）
B-Tree是为磁盘等外存储设备设计的一种平衡查找树

系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。
InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB

	mysql> show variables like 'innodb_page_size';
	
系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB
InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。
B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。

描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。

每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。
两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。

子节点结构
*	pointer	指针		所在磁盘块的地址
*	key		键值		对应表中的主键值
*	data	数据 	除主键外的数据

![3阶的B-Tree结构图](./img/3-B-Tree.png "title") 

## B+Tree

B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。
而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。

在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

>	文件夹与文件

B+Tree相对于B-Tree有几点不同：

1.	非叶子节点只存储键值信息
2.	所有叶子节点之间都有一个链指针
3.	数据记录都存放在叶子节点中

![3阶的B+Tree结构图](./img/3-B+Tree.png "title") 


