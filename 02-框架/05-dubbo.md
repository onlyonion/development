## 简易流程

	Cilent		==> 	Provider
	接口 + 入参 > 序列化 > 发送字节流	---> 接收字节流 > 序列化 > 接口 + 入参

	Provider	==> 	Cilent
	结果 > 序列化 > 发送字节流		---> 接收字节流 > 序列化 > 接口 + 出参

1.	序列化组件，因为需要远程调用，所以需要将参数以二进制流的形式进行编码操作
2.	发送组件，将二进制流发送到服务端
3.	接收组件，接收调用端发送的二进制流以及接收服务端返回的二进制流

将调用端以消费者的身份进行信息注册
监听注册中心的信息变化以刷新本地对服务注册信息的缓存

## 负载均衡 Load Balance

1.	ConsistentHashLoadBalance	一致性Hash策略，具体配置方法可以参考Dubbo文档。相同调用参数的请求会发送到同一个服务提供方节点上，如果某个节点发生故障无法提供服务，则会基于一致性Hash算法映射到虚拟节点上（其他服务提供方）
2.	LeastActiveLoadBalance		根据请求调用的次数计数，处理请求更慢的节点会受到更少的请求
3.	RandomLoadBalance			随机策略，可以设置权重，有利于充分利用服务器的资源，高配的可以设置权重大一些，低配的可以稍微小一些
4.	RoundRobinLoadBalance		轮询策略


## 集群容错模式

1.	FailoverCluster		失败转移，当出现失败，重试其它服务器，通常用于读操作，但重试会带来更长延迟。 default
2.	FailfastCluster 	快速失败，只发起一次调用，失败立即报错，通常用于非幂等性的写操作。
3.	FailsafeCluster		失败安全，出现异常时，直接忽略，通常用于写入审计日志等操作。 
4.	FailbackCluster 	失败自动恢复，后台记录失败请求，定时重发，通常用于消息通知操作。
5.	ForkingCluster		并行调用，只要一个成功即返回，通常用于实时性要求较高的操作，但需要浪费更多服务资源。
6.	BroadcastCluster	广播调用所有提供者，逐个调用，任意一台报错则报错（2.1.0开始支持）。通常用于通知所有提供者更新缓存或日志等本地资源信息。


### 失效转移 FailoverCluster 
当消费端发起一次调用，如果集群容错模式选择的是FailoverCluster模式(缺省模式)，当调用发生失败会自动发起切换，重试其它服务器。


通过循环重复调用方法，如果调用得到响应，则正常返回，产生的异常作为结果的成员。如果得不到响应如超时，网络异常，序列化失败等问题则去尝试重试

通过超时判定实现我们发现，当一个任务处理时间很久，而消费端配置的超时时间又很短就会出现消费端产生超时异常，而服务提供方却成功完成了操作的现象。
因此对服务提供方的处理时间做出规划，配置合理的超时时间，或通过回调方法返回结果给消费端。这样避免消费端发生超时异常，而服务提供方处理完成的问题。

### 快速失败 Failfast Cluster
调用只执行一次，失败则立即报错。这种模式适用于非幂等性操作，每次调用的副作用是不同的，如写操作，比如交易系统我们要下订单，如果一次失败就应该让它失败，通常由服务消费方控制是否重新发起下订单操作请求（另一个新的订单）



## 注册中心
如果不使用注册中心，服务消费方也能够直接调用服务提供方发布的服务，这样需要服务提供方将服务地址暴露给服务消费方，而且也无法使用监控中心的功能，这种方式成为直连。
如果我们使用注册中心，服务提供方将服务发布到注册中心，而服务消费方可以通过注册中心订阅服务，接收服务提供方服务变更通知，这种方式可以隐藏服务提供方的细节，包括服务器地址等敏感信息，而服务消费方只能通过注册中心来获取到已注册的提供方服务，而不能直接跨过注册中心与服务提供方直接连接。这种方式的好处是还可以使用监控中心服务，能够对服务的调用情况进行监控分析，还能使用Dubbo服务管理中心，方便管理服务，我们在这里使用的是这种方式，也推荐使用这种方式

Multicast注册中心
Zookeeper注册中心
Redis注册中心
Simple注册中心





