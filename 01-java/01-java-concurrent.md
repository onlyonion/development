# 1. Java多线程关键字

volatitle, final, synchronized

## 缓存不一致的问题
在增加了增加了L1、L2 Cache之后，CPU何时将变量从独享缓存刷新会共享内存，独享缓存是否从共享内存加载变量，时间上都是不可确定的，这就造成了缓存不一致的问题。

## volatitle
保证共享变量对所有线程可见，但不保证原子性
volatile语义是同步，通过共享变量的方式，完成线程间的通信
volatile保证指令赋值完后的变量立即同步回主内存中，声明并通知其他线程当前赋值的变量已经失效，其他线程在下次使用时会放弃工作内存中变量，使用主内存中的变量。这样就完成了线程间对于volatile修饰的变量的通信。

轻量级的synchronized
不会引起线程上下文的切换和调度

禁止指令重排序优化

### 原子性
原子操作是一个或多个不可中断的操作，要么一次性完全执行完毕，要么就不执行，最终状态不存在有些操作执行完，有些操作没有执行，在外部看来是不可分割的整体（比如化学中的原子，当然原子也是可以再分割的，不过站在分子层面，原子是最小的不可分割的），原子操作关注的是不被线程调度器中断的操作。

volatile关注可见性，而与原子性没有关系。volatile关注点在于从工作内存刷新回主内存，而原子操作关注的是否不被打断。原子和同步目的都是让不同线程可以安全地访问共享变量的两种处理方式，避免造成内存一致性错误。

### 可见性
当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值

## final

*	修饰变量		只读
*	修饰方法		不能被重写
*	修饰类		不能被继承

优点
final关键字提高了性能。JVM和Java应用都会缓存final变量。
final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
使用final关键字，JVM会对方法、变量及类进行优化。

final和abstract这两个关键字是反相关的，final类就不可能是abstract的
final方法在编译阶段绑定，称为静态绑定(static binding)

### 多线程语义
编译器和处理器要遵守两个重排序规则：
在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。

写重排序
JMM禁止编译器把final域的写重排序到构造函数之外。
编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。

读重排序
在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。

## synchronized

1.	修饰普通方法
2.	修饰静态方法
3.	修饰代码块


# 2. Java Object多线程方法 wait(), notify(), notifyAll()

## 等待/通知模式的经典范式
http://www.cnblogs.com/wxd0108/p/5479442.html

### 等待方: 
1.	获取对象的锁 
2.	如果条件不满足 那么调用对象的wait方法 被通知后仍要检查条件、 
3.	条件满足则执行对应的逻辑

伪码:

```java
synchronized(对象){
	while(条件不满足){
		对象.wait()
	}
	对应的处理逻辑
}
```

### 通知方:

1.	获得对象的锁 
2.	改变条件 
3.	通知所有等待在对象上的线程

伪码:

```java
synchronized(对象){
	改变条件
	对象.notifyAll();
}
```

## ThreadLocal
解决多线程中相同变量的访问冲突问题

*	以时间换空间		在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。该变量是多个线程共享的
*	以空间换时间		为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突

ThreadLocalMap存储的键值对中的键是this对象指向的ThreadLocal对象，而值就是你所设置的对象了

# 3. java.util.concurrent
# importnew博文
[importnew博文](http://www.importnew.com/15731.html "title") 

## CountDownLatch
使一个线程等待其他线程完成各自的工作后再执行。
例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。

CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。

![altText](./img/java-concurrent-countdownlanch.png "title") 


### CountDownLatch 如何工作
构造器中的计数值（count）实际上就是闭锁需要等待的线程数量。这个值只能被设置一次，而且CountDownLatch没有提供任何机制去重新设置这个计数值。

与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await()方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。

其他N 个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过 CountDownLatch.countDown()方法来完成的；
每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调 用了这个方法，count的值等于0，然后主线程就能通过await()方法，恢复执行自己的任务。

## CyclicBarrier

## Semaphore

## ConcurrentHashMap

## BlockingQueue

