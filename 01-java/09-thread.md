# 并发编程模型

多线程开发可以更好的发挥多核cpu性能，常用的多线程设计模式有：Future、Master-Worker、Guard Susperionsion、不变、生产者-消费者模式
jdk除了定义了若干并发的数据结构，也内置了多线程框架和各种线程池；锁（分为内部锁、重入锁、读写锁）、ThreadLocal、信号量等在并发控制中发挥着巨大的作用

## Future 模式
将异步请求和代理模式联合的模型产物

Future模式可以在连续流程中满足数据驱动的并发需求，既获得了并发执行的性能提升，又不失连续流程的简洁优雅。

Futrue模式有个重大缺陷：当消费者工作得不够快的时候，它会阻塞住生产者线程，从而可能导致系统吞吐量的下降。所以不建议在高性能的服务端使用。

## MasterWorker模式

Master-Worker模式是常用的并行模式之一，它的核心思想是，系统有两个进程协作工作：Master进程，负责接收和分配任务；Worker进程，负责处理子任务。当Worker进程将子任务处理完成后，结果返回给Master进程，由Master进程做归纳汇总，最后得到最终的结果。

一种将串行任务并行化的方案，被分解的子任务在系统中可以被并行处理，同时，如果有需要，Master进程不需要等待所有子任务都完成计算，就可以根据已有的部分结果集计算最终结果集。

## 生产者-消费者模式
也称作有界缓冲区（bounded-buffer）问题，两个进程共享一个公共的固定大小的缓冲区

生产者-消费模式，通常有两类线程，即若干个生产者线程和若干个消费者线程。生产者线程负责提交用户请求，消费者线程负责具体处理生产者提交的任务。两者之间通过共享内存缓冲去进行通信。

生产-消费模式的核心组件是共享内存缓冲区，是两者的通信桥梁，起到解耦作用，优化系统整体结构。

由于缓冲区的存在，生产者和消费者，无论谁在某一局部时间内速度相对较高，都可以使用缓冲区得到缓解，保证系统正常运行，这在一定程度上缓解了性能瓶颈对系统系能的影响。







# Java内存模型

## Happens-Before规则
1.	程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作
2.	监视器锁规则：对一个锁的解锁，hanppen-before于随后对这个锁的加锁
3.	volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读
4.	传递性：如果A happens-before B，且B happens-before C，那么A happens-before C
5.	start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作
6.	join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before与线程A从ThreadB.join()操作成功返回。


### Disruptor

Disruptor它是一个开源的并发框架，并获得2011 Duke’s 程序框架创新奖，能够在无锁的情况下实现网络的Queue并发操作。
Disruptor是一个高性能的异步处理框架，或者可以认为是最快的消息框架（轻量的JMS），也可以认为是一个观察者模式的实现，或者事件监听模式的实现。 

ClaimStrategy
1.	SingleThreadedStrategy（单线程策略）使用long，没有锁也没有CAS，只有一个生产者，不会产生序号上的冲突
2.	MultiThreadedStrategy（多线程策略）使用了AtomicLong（Java提供的CAS操作），有CAS

队列的目的就是为生产者和消费者提供一个地方存放要交互的数据，帮助缓冲它们之间传递的消息。这意味着缓冲常常是满的（生产者比消费者快）或者空的（消费者比生产者快）。生产者和消费者能够步调一致的情况非常少见。


Disruptor相对于传统方式的优点：

1.	没有竞争=没有锁=非常快。
2.	所有访问者都记录自己的序号的实现方式，允许多个生产者与多个消费者共享相同的数据结构。
3.	在每个对象中都能跟踪序列号（ring buffer，claim Strategy，生产者和消费者），加上神奇的cache line padding，就意味着没有为伪共享和非预期的竞争。

##### CAS（Compare And Swap/Set）操作，CPU级别的指令

##### CPU与缓存
越靠近CPU的缓存越快也越小。所以L1缓存很小但很快(译注：L1表示一级缓存)，并且紧靠着在使用它的CPU内核。
L2大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。
L3在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。
最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。

##### 缓存行 	Cache line
数据在缓存中不是以独立的项来存储的，如不是一个单独的变量，也不是一个单独的指针。
缓存是由缓存行组成的，通常是64字节（译注：这篇文章发表时常用处理器的缓存行是64字节的，比较旧的处理器缓存行是32字节），并且它有效地引用主内存中的一块地址。
一个Java的long类型是8字节，因此在一个缓存行中可以存8个long类型的变量。

##### 缓存行填充 cache line fill
增加补全来确保ring buffer的序列号不会和其他东西同时存在于一个缓存行中

##### 内存屏障 Memory Barriers
a)确保一些特定操作执行的顺序
b)影响一些数据的可见性(可能是某些指令执行后的结果)

内存屏障另一个作用是强制更新一次不同CPU的缓存。
例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。

字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。

内存屏障的确是有开销的——编译器/cpu不能重排序指令，导致不可以尽可能地高效利用CPU，另外刷新缓存亦会有开销。所以不要以为用volatile代替锁操作就一点事都没。

#### 伪共享(False Sharing)

缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。
当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。

当多个线程同时修改一个缓存行里面的多个变量时候，由于同时只能有一个线程操作缓存行，所以相比每个变量放到一个缓存行性能会有所下降，这就是伪共享。

#### java 对象内存布局
HotSpot虚拟机中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。

对于HotSpot JVM，所有对象都有两个字长的对象头。
第一个字是由24位哈希码和8位标志位（如锁的状态或作为锁对象）组成的Mark Word。
第二个字是对象所属类的引用。如果是数组对象还需要一个额外的字来存储数组的长度。每个对象的起始地址都对齐于8字节以提高性能。
