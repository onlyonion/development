《MySQL技术内幕：InnoDB存储引擎》第2版 姜承尧 机械工业出版社

* 体系结构和存储引擎
* 文件、表、索引与算法
* 锁、事务
* 备份与恢复、性能优化

## 第1章 MySQL体系结构和存储引擎
### 1.1 定义数据库和实例
### 1.2 MySQL体系结构
* connectors: native c api, jdbc, odbc, net, php, perl, python, ruby, cobol
* mysql
  * connector pool
  * management service & utillties
  * sql interface: DML,DDL,Stored Procedures Vies, Triggers, etc.
  * parse: Quary Translation Object Privilege
  * optimizer: Access Plaths, statistics
  * catches & buffers: global and engine specific cahces & buffers
* pluggable storage engines
  * memory, index & stroage management
* file system; file & logs
  * ntfs, ufs, ext2/3
  * nfs, san, nas

Mysql组成：
* 连接池组件
* 管理服务和工具组件
  * sql接口组件
  * 查询分析器组件
  * 优化器组件
  * 缓冲组件
* 插件式存储引擎
* 物理文件

存储引擎是基于表的，而不是基于数据库。

### 1.3 MySQL存储引擎
每个存储引擎都有各自的特点（策略模式）。
#### 1.3.1 InnoDB存储引擎
支持事务，行锁设计、支持外接。面向OLTP的应用。
多版本并发控制MVCC来获得并发性，并且实现了sql标准的4种隔离级别。
#### 1.3.2 MyISAM存储引擎
不支持事务、表锁设计，支持全文检索，面向OLAP应用。
#### 1.3.3 NDB存储引擎
#### 1.3.4 Memory存储引擎
#### 1.3.5 Archive存储引擎
#### 1.3.6 Federated存储引擎
#### 1.3.7 Maria存储引擎
#### 1.3.8 其他存储引擎
### 1.4 各存储引擎之间的比较
### 1.5 连接MySQL

## 第2章 InnoDB存储引擎
### 2.1 InnoDB存储引擎概述
### 2.2 InnoDB存储引擎的版本
### 2.3 InnoDB体系架构
#### 2.3.1 后台线程
1. Master Thread
2. IO Thread AIO
3. Purge Thread 回收已使用并分配的undo页

#### 2.3.2 内存
1. 缓冲池
2. LRU List、Free List和Fush Lish
   * LRU 最频繁使用的页在LRU列表的前端、最少使用的页在LRU列表的尾端。释放尾端
3. 重做日志缓冲
   
### 2.4 Checkpoint技术
### 2.5 Master Thread工作方式
### 2.6 InnoDB关键特性
### 2.7 启动、关闭与恢复

## 第3章 文件
### 3.1 参数文件
启动配置参数文件，定义某种内存结构有多大等。
### 3.2 日志文件
错误日志、二进制日志、慢查询日志、查询日志
#### 3.2.1 错误日志
#### 3.2.2 慢查询日志
#### 3.2.3 查询日志
#### 3.2.4 二进制日志
### 3.3 套接字文件
### 3.4 pid文件
### 3.5 表结构定义文件
插件式存储引擎。frm为后缀名的文件，记录了该表的表结构定义。
### 3.6 InnoDB存储引擎文件
#### 3.6.1 表空间文件
默认表空间文件，ibdata1，10MB。innodb_data_file_path对其设置。
#### 3.6.2 重做日志文件

## 第4章 表
### 4.1 索引组织表
### 4.2 InnoDB逻辑存储结构
所有的数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。表空间又由段（segement）、区（extent）、页（page）组成。页在一些文档中有时也被称为块（block）。
tablespace -> segment -> extent -> page -> row

#### 4.2.1 表空间 tablespace
#### 4.2.2 段 segment
表空间是由各个段组成的，常见的段有**数据段**、**索引段**、**回滚段**等。
InnoDB存储引擎表是索引组织的（index organized），因此数据即索引，索引即数据。
那么数据段即为B+树的页节点（上图的leaf node segment），索引段即为B+树的非索引节点（上图的non-leaf node segment）。

#### 4.2.3 区 extent
区是由连续页组成的空间，在任何情况下每个区的大小都为`1MB`。

区是由`64`个连续的页组成的，每个页大小为`16KB`，即每个区的大小为`1MB`。
对于大的数据段，InnoDB存储引擎最多每次可以申请4个区，以此来保证数据的顺序性能。

#### 4.2.4 页 page/block
页是InnoDB磁盘管理的最小单位。

#### 4.2.5 行 row
InnoDB是面向列的（row-oriented），数据是按行进行存放的。每个页存放的行记录也是有硬性定义的，最多允许存放`16KB/2 - 200`行的记录，即`7992`行记录。

面向列的数据库，google big table。

##### 物理存储结构
从物理意义上来看，InnoDB表由共享表空间、日志文件组（更准确地说，应该是Redo文件组）、表结构定义文件组成。
若将innodb_file_per_table设置为on，则每个表将独立地产生一个表空间文件，以ibd结尾，数据、索引、表的内部数据字典信息都将保存在这个单独的表空间文件中。
表结构定义文件以frm结尾，这个是与存储引擎无关的，任何存储引擎的表结构定义文件都一样，为.frm文件。

### 4.3 InnoDB行记录格式
### 4.4 InnoDB数据页结构
### 4.5 Named File Formats机制
### 4.6 约束
#### 4.6.1 数据完整性
#### 4.6.2 约束的创建和查找
#### 4.6.3 约束和索引的区别
约束更是一个逻辑的概念，用来保证数据的完整性，索引是一个数据结构，既有逻辑上的概念，在数据库中还代表这物理存储方式。
#### 4.6.4 对错误数据的约束
#### 4.6.5 ENUM和SET约束
#### 4.6.6 触发器与约束
#### 4.6.7 外键约束
一般来说，称被引用的表为父表，引用的表成为子表。
### 4.7 视图
### 4.8 分区表
分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库的应用而言，从逻辑上将，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。  
MySQL数据库支持的分区类型为水平分区（同一个表中不同的**行**的记录分配到不同的物理文件中），不支持垂直分区（同一个表中不同的**列**的记录分配到不同的物理文件中）。
#### 4.8.5 分区和性能
数据库的应用分为两类：
* OLTP（在线事务处理） Blog、电子商务、网络游戏等 分区需要小心
* OLAP（在线分析处理） 数据仓库、数据集市 分区可提高查询性能

## 第5章 索引与算法
### 5.1 InnoDB存储引擎索引概述
B+树索引 B 代表 平衡balance，而不是二叉binary。
### 5.2 数据结构与算法
#### 5.2.1 二分查找法
又称拆半查找法。基本思想：将记录按有序化排序，在查找过程中采用跳跃式查找。
#### 5.2.2 二叉查找树和平衡二叉树
### 5.3 B+树
B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树。
所有记录节点**按照键值大小顺序**存放在同一层的**叶子节点**上，由各叶子节点指针进行连接。
#### 5.3.1 B+树的插入操作
三种情况
1. leaf page不满、index page不满
2. leaf page满、index page不满
3. leaf page满、index page满

拆分页操作 -> 旋转

#### 5.3.2 B+树的删除操作
使用填充因子来控制树的删除变化。

### 5.4 B+树索引
B+树索引在数据库中有一个特点是高扇出性，在数据库中，B+树的高度一般都是2-4层，查找某一行记录最多只需要2-4次IO。
聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。
#### 5.4.1 聚集索引
实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。
#### 5.4.2 辅助索引
对于辅助索引（也称非聚集索引），叶节点不包含行的全部数据。
辅助索引的存在并不影响数据在聚集索引中的组织。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后通过主键索引来找到一个完整的行记录。
#### 5.4.3 B+树索引的分裂
#### 5.4.4 B+树索引的管理

### 5.5 Cardinality值
### 5.6 B+树索引的使用
#### 5.6.1 不同应用中B+树索引的使用
#### 5.6.2 联合索引
联合索引也是一颗B+树，不同的是联合索引的键值的数量不是1，而是大于等于2.
```sql
key idx_a_b(a, b)
// 走索引
select * from table where a='x'; 
select * from table where a='x' and b='y';
// 不走索引
select * from table where b='y';
```
联合索引的第二个好处是已经对第二个键值进行了排序处理。取a等值查询，然后按照b排序，使用联合索引可以避免多一次的排序操作。
#### 5.6.3 覆盖索引
covering index，从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。
#### 5.6.4 优化器选择不使用索引的情况
#### 5.6.5 索引提示
#### 5.6.6 Multi-Range Read优化
#### 5.6.7 Index Condition Pushdown（ICP）优化
### 5.7 哈希算法
时间复杂度O(1)，每个数据库中都存在该数据结构。
#### 5.7.1 哈希表
哈希表也称散列表，由直接寻址表改进而来。哈希碰撞、哈希冲突，在数据库中一般用链接法解决，把散列到同一槽中的所有元素都放在一个链表中。
#### 5.7.2 InnoDB存储引擎中的哈希算法
#### 5.7.3 自适应哈希索引
自适应哈希索引经哈希函数映射到一个哈希表中，因此对于字典类型的查找非常快速，但对于范围查找无能为力。
* 哈希索引只能用来搜素等值的查询。

### 5.8 全文检索
辅助表中存储了单词与单词自身在一个或多个文档中所在的位置之间的映射，通常通过关联数组实现。
#### 5.8.1 概述
#### 5.8.2 倒排索引
#### 5.8.3 InnoDB全文检索
#### 5.8.4 全文检索

## 第6章 锁
### 6.1 什么是锁
锁机制用于管理对**共享资源**的并发访问，提供数据的**完整性和一致性**。
操作缓冲池中的LRU列表，删除、添加、移动LRU列表的元素，为了保证一致性，必须有锁的介入。

### 6.2 lock与latch
### 6.3 InnoDB存储引擎中的锁
### 6.4 锁的算法
#### 6.4.1 行锁的3种算法
1. Record Lock 单个行记录上的锁
2. Gap Lock 间隙锁，锁定一个范围，但是不包括记录本身
3. Next-Key Lock 锁定一个范围，并且锁定记录本身
   
#### 6.4.2 解决Phantom Problem
在默认的事务隔离级别下（Repeatable Read），InnoDB存储引擎采用Next-Key Locking机制来避免Phantom Problem。

Phantom Problem是指在同一事务下，连续执行两次同样的Sql语句可能导致不同的结果，第二次的sql语句可能会返回之前不存在的行。

### 6.5 锁问题
#### 6.5.1 脏读
脏数据是指事务对缓冲池中行记录的修改，并且还没有被提交（commit）。违背了事务的隔离性。   
脏读指的就是在不同的事务下，当前事务可以读到另外事务未提交的数据，简单来说就是可以读到脏数据。
#### 6.5.2 不可重复读
不可重复读是指在一个事务内多次读取同一数据集合。在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作。

脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但是违背了数据库事务一致性的要求。
#### 6.5.3 丢失更新
丢失更新时另一个锁导致的问题，简单来说就是一个事务的更新操作会被另一个事务的更新操作锁覆盖，从而导致数据的不一致。  
避免丢失更新发生，需要让事务在这种情况下的操作变成串行化，而不是并行操作。
### 6.6 阻塞
因为不同锁之间的兼容关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放他所占用的资源，这就是阻塞。
### 6.7 死锁
### 6.8 锁升级
锁升级是指当前锁的**粒度降低**。多个行锁升级为一个页锁，或将页锁升级为表锁。
行锁 -> 页锁 -> 表锁。这种升级保护了系统资源，防止系统使用太多的内存来维护锁，在一定程度上提高了效率。

PS：Java中自旋锁、偏向锁、轻量级锁、重量级锁、锁粗化、锁消除

## 第7章 事务
### 7.1 认识事务
#### 7.1.1 概述
* 原子性
* 一致性 事务将数据库从一种状态转变为下一种一致的状态。完整性约束不会被破坏。如唯一约束。
* 隔离性 其他称呼，并发控制、可串行化、锁。一个事务提交前对其他事务都不可见。
* 持久性 一旦提交，结果是永久性的。即使宕机也能恢复。若RAID卡损坏、自然灾害等外部原因，仍可能丢失。

#### 7.1.2 分类
1. 扁平事务
2. 带有保存点的扁平事务
3. 链事务
4. 嵌套事务
5. 分布式事务

### 7.2 事务的实现
事务的隔离性由锁实现。原子性、一致性、持久型通过数据库的redo log和undo log来完成。
redo log称为重做日志，用来保证事务的原子性和持久性。undo log用来保证事务的一致性。

### 7.3 事务控制语句
### 7.4 隐式提交的SQL语句
### 7.5 对于事务操作的统计
### 7.6 事务的隔离级别
隔离级别越低，事务请求的锁越少或保持锁的时间就越短。这是为什么大多数据库的默认事务隔离级别是READ COMMITED。

repeatedable read与serializable的性能开销几乎一样，read commited性能也不会大幅度提升。
### 7.7 分布式事务
#### 7.7.1 MySQL数据库分布式事务
XA事务由一个或多个资源管理器（Resource Managers）、一个事务管理器（Transaction Manager）以及一个应用程序（Application Program）组成。
* 资源管理器 提供访问事务资源的方法。通常一个数据库就是一个资源管理器。
* 事务管理器 协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。
* 应用程序 定义事务的边界，指定全局事务中的操作。

#### 7.7.2 内部XA事务
MySQL数据库中的另外一种分布式事务，在存储引擎与插件之间，又或者在存储引擎与存储引擎之间，称之为内部XA事务。
binlog与InnoDB存储引擎之间。

### 7.8 不好的事务习惯
### 7.9 长事务
执行时间较长的事务。有时可以转化为小批量（mini batch）的事务来进行。

## 第8章 备份与恢复
### 8.1 备份与恢复概述
### 8.2 冷备
### 8.3 逻辑备份
### 8.4 二进制日志备份与恢复
### 8.5 热备
### 8.6 快照备份
### 8.7 复制

## 第9章 性能调优
### 9.1 选择合适的CPU
OLTP是IO密集型的操作，OLAP是CPU密集型的操作。
### 9.2 内存的重要性
InnoDB存储引擎既缓存数据，又缓存索引，并将它们缓存于一个很大的缓冲池中，InnoDB Buffer Pool。
### 9.3 硬盘对数据库性能的影响
#### 9.3.1 传统机械硬盘
机械硬盘的指标，寻道时间，转速。
#### 9.3.2 固态硬盘
### 9.4 合理地设置RAID
### 9.5 操作系统的选择
### 9.6 不同的文件系统对数据库性能的影响
### 9.7 选择合适的基准测试工具
#### 9.7.1 sysbench
#### 9.7.2 mysql-tpcc

## 第10章 InnoDB存储引擎源代码的编译和调试