《HotSpot实战》 陈涛 著 人民邮电出版社

网易宝

## 第1章 初试HotSpot
### 1.1 JDK概述
### 1.2 动手编译虚拟机
### 1.3 实战：在Hotspot内调试Helloworld

## 第2章 启动
### 2.1 HotSpot内核
数据结构包括结构体、枚举、类和接口，它定义了数据成员，用以支撑算法的实现。算法反应了功能的实现逻辑。
#### 2.1.2 HotSpot内核框架
HotSpot由多个顶层模块组成，主要包括Service、Prims、Rutime、Classfile、Interperter、Code、Memory、Compiler、Oops、C1/Opto/Shark和GC。

### 2.2 启动
### 2.3 系统初始化

## 第3章 类与对象
面向对象如何在HotSpot里实现？对象与类如何实现？
### 3.1 对象的表示机制
#### 3.1.1 OOP-Klass二分模型
* OOP：ordinary object pointer, oops 普通对象指针，用来描述对象实例信息
* Klass：Java类的C++对等体，用来描述Java类
Klass对象向JVM提供两个功能：实现语言层面的Java类；实现Java对象的分发功能。
#### 3.1.2 Oops模块
#### 3.1.3 OOP框架与对象访问机制
每创建一个Java对象，在JVM内部也会相应创建一个OOP对象来表示Java对象。
instanceOopDesc表示类实例，arrayOopDesc表示数组
#### 3.1.4 Klass与instanceKlass
#### 3.1.5 实战：用HSDB雕饰HotSpot
### 3.2 类的状态转换
#### 3.2.1 入口：Class文件
class文件格式
#### 3.2.2 类的状态
```graphviz
digraph jvm_load_class {
    rankdir=LR;
    //node [shape = circle];
    link [shape=record, label="{link|{verify|prepare|resolve}}"];
    "*.class" -> load;
    load -> link;
    link -> init;
    init -> Class [style = dotted];
}
```
#### 3.2.3 加载
#### 3.2.4 链接
1. 验证
2. 准备
3. 解析
#### 3.2.5 初始化
#### 3.2.6 实战：类的“族谱”
#### 3.2.7 实战：系统字典
* 加载 ClassFileParser类ParseClassFile()函数
### 3.3 创建对象
new -> 常量池中索引，定位目标对象类型 -> 内存分配 -> 对象头和实例数据初始化
#### 3.3.1 实例对象的创建流程
* 快速分配 类已被加载和正确解析 TLAB(UseTLAB) -> Eden需要加锁；对象头（设置MarkWord，设置类型指针）
* 慢速分配 尚未解析
#### 3.3.2 实战：探测JVM内部对象

## 第4章 运行时数据区
堆与方法区所占的内控空间，由JVM负责管理，内存分配由HotSpot的内存管理模块维护，内存释放有垃圾收集器自动完成。
### 4.1 堆
#### 4.1.1 Java的自动内存管理
#### 4.1.2 堆的管理
1. 分代
2. Universe模块
### 4.2 线程私有区域
#### 4.2.1 PC
#### 4.2.2 JVM栈
### 4.3 方法区
#### 4.3.1 纽带作用
方法区存储信息：类型基本描述信息和域（字段域和方法域）信息
#### 4.3.2 常量池
#### 4.3.3 常量池缓存：ConstantPollCache
#### 4.3.4 方法的表示：methodOop
#### 4.3.5 方法的解析：将符合引用转换成直接引用
#### 4.3.6 代码放在哪里：ConstMethodOop
#### 4.3.7 实战：探测运行时常量池
### 4.4 性能监控数据区：PerfData
JVM中开辟的共享内存，存放关于性能统计的计数器。使用共享内存的方式向外部进程提供通信手段，允许外部监控进程attach至虚拟机进程，并从共享内存中读取这些PerfData
### 4.5 转储

## 第5章 垃圾收集
### 5.1 堆与GC
#### 5.1.1 垃圾收集
1. 垃圾收集器
2. 收集算法
#### 5.1.2 分代收集
#### 5.1.3 快速分配
大量连续内存，**碰撞指针**
#### 5.1.4 栈上分配和逸出分析
分析局部变量的作用域仅限于方法内部，则JVM直接在栈帧内分配对象空间，避免在堆中分配。
#### 5.1.5 GC公共模块
### 5.2 垃圾收集器
#### 5.2.1 设计演进
1. 串行收集器：Serial
2. 并行收集器：ParNew
3. 吞吐量优先收集器：Parallel Scanvenge
4. 堆的类型
5. 收集策略
#### 5.2.2 CMS收集器
#### 5.2.3 G1收集器
### 5.3 实战：性能分析方法
#### 5.3.1 获取GC日志
#### 5.3.2 GC监控信息
#### 5.3.3 内存分析工具
#### 5.3.4 选择合适的收集器与GC性能评估
#### 5.3.5 不要忽略JVM Crash日志

## 第6章 栈
### 6.1 硬件背景：了解真实机器
#### 6.1.1 程序是如何运行的
#### 6.1.2 x86与栈帧
真实机器中处理器、寄存器与栈
寄存器是CPU计算单元的存储单元，用来保存计算过程中的各种操作数：立即数、整数、存储器引用地址等。
多数指令具有一个或多个操作数（operand），操作数表示执行该指令操作中要引用的**源数据值**，以及放置指令执行结果的目标数据。
x86支持3种操作数格式：
1. 立即数（），即常量；
2. 寄存器（register），表示寄存器中存的值；
3. 存储器引用，根据某个有效地址访问某个存储器
指令读取操作数方式的不同决定了指令具有不同的寻址模式。
#### 6.1.3 ARM对Java硬件级加速：Jazelle技术
### 6.2 Java栈
寄存器式指令集：许多硬件体系围绕着寄存器存取中间运算数据，相应地，在寻址方式上也是围绕着寄存器进行设计。
#### 6.2.1 寄存器式指令集与栈式指令集
寄存器的优点是访问效率高，缺点是数量有限。
#### 6.2.2 HotSpot中的栈
1. 栈帧 用于支持虚拟机进行方法调用和方法执行的数据结构，它是JVM运行时数据区中的虚拟机栈元素。
#### 6.2.3 栈帧
#### 6.2.4 充分利用寄存器资源
#### 6.2.5 虚拟机如何调用Java函数
1. 入口：JavaCalls
2. 实际例程：CallStub
3. Stub Rountiness
4. CallStub的运行过程
#### 6.2.6 优化：栈顶缓存
栈顶缓存（Top of Stack Cashing，TOSCA/TOS）。将频繁访问的栈顶元素存储在CPU硬件寄存器中，大幅减少内存访问次数，提升性能。

## 第7章 解释器和即时编译器
java编译器  .java  -> .class(bytecode)
解释器      .class -> machine code
即时编译器  .class -> machine code
### 7.1 概述
解释器 解释器，代码生成器，InterpreterCodelet，转发表（dispatch table）
JIT编译器 C1：client，C2：server
### 7.2 解释器如何工作
#### 7.2.1 Interpreter模块
#### 7.2.2 Code模块
#### 7.2.3 字节码表
#### 7.2.4 CodeCache
#### 7.2.5 InterpreterCodelet与Stub队列
#### 7.2.6 Code生成器
#### 7.2.7 模板表与转发表
### 7.3 即时编译器
#### 7.3.1 概述
#### 7.3.2 编译器模块
#### 7.3.3 编译器的基本结构
字节码 -> HIR -> LIR -> 机器码
1. 编译器前端将Java字节码解释成一种抽象格式HIR（High-level Intermediate Representation，高级中间表示）
2. 编译器后端将HIR转换成LIR
3. 对完成底层优化后的LIR，采用线性扫描寄存器分配算法，进行寄存器的分配。将物理寄存器替换掉LIR中的虚拟寄存器后，生成符合目标机器体系结构的机器码

## 第8章 指令集
JVM指令集
### 8.1 再说栈式指令集
### 8.2 数据传送
### 8.3 类型转换
### 8.4 对象的创建和操作
### 8.5 程序流程控制
### 8.6 运算
#### 8.6.1 加法：iadd
#### 8.6.2 取负：ineg
### 8.7 函数的调用和返回
#### 8.7.1 Java函数分发机制：VTABLE与ITABLE
#### 8.7.2 invoke系列指令
#### 8.7.3 动态分发：覆盖
面向对象特点：抽象，封装，继承，多态
函数的覆盖和重载是多态性的不同表现。覆盖描述的是父类与子类直接的多态性，重载描述的一个类多个函数直接的多态性。
#### 8.7.4 静态分发：重载
### 8.8 异常

## 第9章 虚拟机监控工具
### 9.1 Attach机制
连接机制监控访问虚拟机进程
连接到目标JVM的过程，建立一个进程间通信通道，通过通道，由客户进程向JVM进程下发命令，JVM进程向客户进程返回数据的过程。
### 9.2 查看JVM进程
jsp
### 9.3 查看和配置JVM
jinfo
### 9.4 堆内存转储工具
jmap
#### 9.4.1 Heap Dump
head dump文件是二进制文件，保持了某一时刻JVM堆中对象的内存使用情况，可分析是否存在内存溢出等情况。
#### 9.4.2 原理
### 9.5 堆转储分析
jhat, mat, jstat
#### 9.5.1 Heap Dump分析工具：jhat
分析heap dump文件，启动一个http服务器，将堆中对象的信息以动态网页的形式呈现
#### 9.5.2 实战：MAT分析过程
1. 生成heap dump
2. 查看对象分配了多少空间
3. 内存泄漏
### 9.6 线程转储分析
#### 9.6.1 jstack
#### 9.6.2 实战：如何分析资源等待
1. 获取线程转储信息
2. 判断是否死锁
3. 定位资源瓶颈 明确应用程序所等待的资源
4. 对症下药
